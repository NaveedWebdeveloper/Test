a:2:{s:4:"meta";a:3:{s:5:"title";s:15:"TemplaVoila API";s:5:"descr";s:0:"";s:7:"options";a:2:{s:10:"usageCount";N;s:19:"includeCodeAbstract";s:1:"1";}}s:5:"files";a:8:{s:14:"MD5_5c642e71a0";a:4:{s:8:"filename";s:28:"class.tx_templavoila_cm1.php";s:8:"filesize";i:6167;s:6:"header";a:5:{s:4:"text";s:79:"

Class which will add menu items to click menus for the extension TemplaVoila
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:42:"@author	Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:3:{i:1;a:8:{s:6:"header";s:26:"class tx_templavoila_cm1 {";s:5:"class";i:1;s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:79:"

Class which will add menu items to click menus for the extension TemplaVoila
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:42:"@author	Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:7:"content";a:2:{i:0;s:3:"	
	";i:1;i:-1;}s:12:"content_size";i:3;s:13:"content_lines";i:1;s:6:"atLine";i:59;}i:3;a:4:{s:6:"header";s:49:"function main(&$backRef,$menuItems,$table,$uid)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:55:"

Main function, adding items to the click menu array.
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"object";i:1;s:79:"Reference to the parent object of the clickmenu class which calls this function";}i:1;a:2:{i:0;s:5:"array";i:1;s:116:"The current array of menu items - you have to add or remove items to this array in this function. Thats the point...";}i:2;a:2:{i:0;s:6:"string";i:1;s:30:"The database table OR filename";}i:3;a:2:{i:0;s:7:"integer";i:1;s:28:"For database tables, the UID";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:24:"The modified menu array.";}}s:6:"atLine";i:70;}i:5;a:7:{s:6:"header";s:22:"function includeLL()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:92:"

Includes the [extDir]/locallang.php and returns the $LOCAL_LANG array found in that file.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:50:"The $LOCAL_LANG array from the locallang.php file.";}}s:7:"content";a:2:{i:0;s:321:"		include(t3lib_extMgm::extPath('templavoila').'locallang.php');
		return $LOCAL_LANG;
	}
} 

if (defined('TYPO3_MODE') && $TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/class.tx_templavoila_cm1.php'])	{
	include_once($TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/class.tx_templavoila_cm1.php']);
}
?>
";i:1;i:0;}s:12:"content_size";i:321;s:13:"content_lines";i:9;s:6:"atLine";i:163;}}}s:14:"MD5_3a656fcfbd";a:4:{s:8:"filename";s:51:"class.tx_templavoila_handlestaticdatastructures.php";s:8:"filesize";i:5986;s:6:"header";a:5:{s:4:"text";s:104:"

Class/Function which manipulates the item-array for table/field tx_templavoila_tmplobj_datastructure.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:45:"@author    Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:5:{i:1;a:8:{s:6:"header";s:49:"class tx_templavoila_handleStaticDataStructures {";s:5:"class";i:1;s:11:"parentClass";s:41:"tx_templavoila_handleStaticDataStructures";s:4:"cDat";a:5:{s:4:"text";s:104:"

Class/Function which manipulates the item-array for table/field tx_templavoila_tmplobj_datastructure.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:45:"@author    Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:7:"content";a:2:{i:0;s:29:"	var $prefix = 'Static: ';

	";i:1;i:-1;}s:12:"content_size";i:29;s:13:"content_lines";i:2;s:6:"atLine";i:56;}i:3;a:7:{s:6:"header";s:35:"function main(&$params,&$pObj)    {";s:11:"parentClass";s:41:"tx_templavoila_handleStaticDataStructures";s:4:"cDat";a:3:{s:4:"text";s:90:"

Adds static data structures to selector box items arrays.
Adds ALL available structures
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:35:"Array of items passed by reference.";}i:1;a:2:{i:0;s:6:"object";i:1;s:76:"The parent object (t3lib_TCEforms / t3lib_transferData depending on context)";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:324:"		// Adding an item!
		if (is_array($GLOBALS['TBE_MODULES_EXT']['xMOD_tx_templavoila_cm1']['staticDataStructures']))	{
			foreach($GLOBALS['TBE_MODULES_EXT']['xMOD_tx_templavoila_cm1']['staticDataStructures'] as $val)	{
				$params['items'][]=Array($this->prefix.$val['title'], $val['path'], $val['icon']);
			}
		}
    }

	";i:1;i:0;}s:12:"content_size";i:324;s:13:"content_lines";i:8;s:6:"atLine";i:67;}i:5;a:7:{s:6:"header";s:42:"function main_scope1(&$params,&$pObj)    {";s:11:"parentClass";s:41:"tx_templavoila_handleStaticDataStructures";s:4:"cDat";a:3:{s:4:"text";s:100:"

Adds static data structures to selector box items arrays.
Adds only structures for Page Templates
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:35:"Array of items passed by reference.";}i:1;a:2:{i:0;s:6:"object";i:1;s:76:"The parent object (t3lib_TCEforms / t3lib_transferData depending on context)";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:335:"		if (is_array($GLOBALS['TBE_MODULES_EXT']['xMOD_tx_templavoila_cm1']['staticDataStructures']))	{
			foreach($GLOBALS['TBE_MODULES_EXT']['xMOD_tx_templavoila_cm1']['staticDataStructures'] as $val)	{
				if ($val['scope']==1)	{
					$params['items'][]=Array($this->prefix.$val['title'], $val['path'], $val['icon']);
				}
			}
		}
	}

	";i:1;i:0;}s:12:"content_size";i:335;s:13:"content_lines";i:9;s:6:"atLine";i:84;}i:7;a:4:{s:6:"header";s:42:"function main_scope2(&$params,&$pObj)    {";s:11:"parentClass";s:41:"tx_templavoila_handleStaticDataStructures";s:4:"cDat";a:3:{s:4:"text";s:111:"

Adds static data structures to selector box items arrays.
Adds only structures for Flexible Content elements
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:35:"Array of items passed by reference.";}i:1;a:2:{i:0;s:6:"object";i:1;s:76:"The parent object (t3lib_TCEforms / t3lib_transferData depending on context)";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:6:"atLine";i:102;}i:9;a:7:{s:6:"header";s:39:"function pi_templates(&$params,$pObj)	{";s:11:"parentClass";s:41:"tx_templavoila_handleStaticDataStructures";s:4:"cDat";a:3:{s:4:"text";s:90:"

Adds Template Object records to selector box for Content Elements of the "Plugin" type.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:35:"Array of items passed by reference.";}i:1;a:2:{i:0;s:6:"object";i:1;s:76:"The parent object (t3lib_TCEforms / t3lib_transferData depending on context)";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"			// Find the template data structure that belongs to this plugin:
		$piKey = $params['row']['list_type'];
		$templateRef = $GLOBALS['TBE_MODULES_EXT']['xMOD_tx_templavoila_cm1']['piKey2DSMap'][$piKey];	// This should be a value of a Data Structure.
		$storagePid = intval($pObj->cachedTSconfig[$params['table'].':'.$params['row']['uid']]['_STORAGE_PID']);		// This should b
[...]
de_once($TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/class.tx_templavoila_handlestaticdatastructures.php']);
}
?>
";i:1;i:1;}s:12:"content_size";i:1741;s:13:"content_lines";i:29;s:6:"atLine";i:119;}}}s:14:"MD5_e1f7a76790";a:4:{s:8:"filename";s:35:"class.tx_templavoila_htmlmarkup.php";s:8:"filesize";i:44410;s:6:"header";a:5:{s:4:"text";s:155:"

HTML markup/search class; can mark up HTML with small images for each element AND as well help you extract parts of the HTML based on a socalled 'PATH'.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:42:"@author	Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:26:{i:1;a:8:{s:6:"header";s:33:"class tx_templavoila_htmlmarkup {";s:5:"class";i:1;s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:5:{s:4:"text";s:155:"

HTML markup/search class; can mark up HTML with small images for each element AND as well help you extract parts of the HTML based on a socalled 'PATH'.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:42:"@author	Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:7:"content";a:2:{i:0;s:5269:"
 		// CONFIG:
	/**
	 * Determines which mode is used for markup. Options are:
	 * 	'explode' : In this mode A) container elementers (tables, tablecells...) are marked with borders and B) all the tag-images inserted are inserted 'relative' to the content which means no tag images can be layered over each other. Best mode if you want access to all elements (analytic) BUT it also spoils the page design the most of the options.
	 *  'borders' : In this mode container elementers (tables, tablecells...) are marked with borders
	 *  'source'  : In this mode all the HTML code is shown as source code. This mode should be used if you want code-insight OR analyse non-HTML code (like XML or WML)
	 *  default   :	Original page is preserved and tag-images are added as layers (thus non-destructive). However tag-images may overlap each other so you cannot access the tag images you want.
	 */
	var $mode = '';	// [blank], 
	var $maxLineLengthInSourceMode = 150;	// When in source mode the lines are truncated with "..." if longer than this number of characters.

	/**
	 * The mode by which to detect the path of elements
	 * TRUE (1)	: Default path detection; Will reset path by #id attributes. Will include class-attributes for elements. For the rest, its numeric.
	 * FALSE 	: No path detection applied
	 *
	 * Currently only one path mode is used. However the idea is if other path modes might be liked in the future. But for now, that is not the case.
	 */
	var $pathMode = '1';

	/**
	 * Maximum recursions into the HTML code. Works as a break to avoid run-away function calls if that is potentially possible.
	 */
	var $maxRecursion = 99;	

	var $onlyElements='';	// Commalist of lowercase tag names which are the only ones which will be added as "GNYF" tag images. If empty, ALL HTML tags will have these elements.
	var $checkboxPathsSet=array();		// Array with header section paths to set checkbox for.
	
		// INTERNAL STATIC:
		
	/**
	 * This defines which tags can be exploded. Input lists of tags will be limited to those entered here.
	 * You can override this array with an external setup in case you want to analyse non-HTML (XML or WML). For HTML you should probably keep these values.
	 *
	 * Notice that there is a distinction between "block elements" which has a begin AND end tag (eg. '<table>...</table>' or '<p>...</p>') and "single elements" which is stand-alone (eg. '<img>'). I KNOW that in XML '<p>..</p>' with no content can legally be '<p/>', however this class does not support that at the moment (and will in fact choke..)
	 * For each element you can define and array with key/values;
	 *   'single' => TRUE					:	Tells the parser that this tag is a single-tag, stand alone (eg. '<img>', '<input>' or '<br>')
	 *   'anchor_outside' => TRUE			:	(Block elements only) This means that the tag-image for this element will be placed outside of the block. Default is to place the image inside.
	 *   'wrap' => array('before','after')	:	(Block elements only) This means that the tag-image for this element will be wrapped in those HTML codes before being placed. Notice how this is cleverly used to represent '<tr>...</tr>' blocks.
	 */
	var $tags = array(
			// Block elements:
		'a' => array('anchor_outside'=>1),
		'b' => array(),
		'blockquote' => array(),
		'body' => array(),
		'div' => array(),
		'em' => array(),
		'font' => array(),
		'form' => array('anchor_outside'=>1),
		'h1' => array(),
		'h2' => array(),
		'h3' => array(),
		'h4' => array(),
		'h5' => array(),
		'h6' => array(),
		'i' => array(),
		'li' => array(),
		'map' => array('anchor_outside'=>1),
		'ol' => array('anchor_outside'=>1),
		'option' => array('anchor_outside'=>1,'wrap'=>array('</select>','<select>')),
		'p' => array(),
		'pre' => array(),
		'select' => array('anchor_outside'=>1),
		'span' => array(),
		'strong' => array(),
		'table' => array('anchor_outside'=>1),
		'td' => array(),
		'textarea' => array('anchor_outside'=>1),
		'tr' => array('wrap'=>array('<td>','</td>')),
		'u' => array(),
		'ul' => array('anchor_outside'=>1),
		'iframe' => array('anchor_outside'=>1),
#		'tbody' => array(),
#		'thead' => array(),

			// Single elements:
		'br' => array('single'=>1),
		'hr' => array('single'=>1),
		'img' => array('single'=>1),
		'input' => array('single'=>1),
		'area' => array('single'=>1),
#		'embed' => array('anchor_outside'=>1),
	);
	

		// INTERNAL dynamic
	var $htmlParse = '';		// Will contain the HTML-parser object. (See init())
	var $backPath = '';			// Will contain the backend back-path which is necessary when marking-up the code in order to fix all media paths.
	var $gnyfPath = '';			// Will contain the path to the tag-images ("gnyfs")
	var $gnyfStyle = '';		// will contain style-part for gnyf images. (see init())
	var $gnyfImgAdd = '';		// Eg. 	onclick="return parent.mod.updPath('###PATH###');"	
	var $pathPrefix='';			// Prefix for the path returned to the mod frame when tag image is clicked.
	var $tDat='';
	
	var $elCountArray=array();	// Used to register the paths during parsing the code (see init())
	var $elParentLevel=array();	// Used to register the all elements on the same level
	var $searchPaths = '';		// Used to contain the paths to search for when searching for a paths. (see getContentBasedOnPath())
	

	







	";i:1;i:-1;}s:12:"content_size";i:5269;s:13:"content_lines";i:109;s:6:"atLine";i:83;}i:3;a:7:{s:6:"header";s:79:"function markupHTMLcontent($content,$backPath,$relPathFix,$showTags,$mode='')	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:84:"

Marks up input HTML content string with tag-images based on the list in $showTags
";s:5:"param";a:5:{i:0;a:2:{i:0;s:6:"string";i:1;s:12:"HTML content";}i:1;a:2:{i:0;s:6:"string";i:1;s:84:"Backend module BACK_PATH - used to set the right position for the tag-images (gnyfs)";}i:2;a:2:{i:0;s:6:"string";i:1;s:201:"The relative path from module position back to the HTML-file position; used to correct paths of HTML since the HTML is modified so it can display correctly from the path of the module using this class.";}i:3;a:2:{i:0;s:6:"string";i:1;s:128:"Comma list of tags which should be exploded. Notice that tags in this list which does not appear in $this->tags will be ignored.";}i:4;a:2:{i:0;s:6:"string";i:1;s:119:"The mode of display; [blank], explode, borders. Set in $this->mode. "checkbox" is also an option, used for header data.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:13:"Modified HTML";}}s:7:"content";a:2:{i:0;s:507:"			// Initialize:
		$this->mode = $mode;
		
		$this->init();
		$this->backPath = $backPath;
		$this->gnyfPath = t3lib_div::resolveBackPath($backPath.t3lib_extMgm::extRelPath('templavoila'));
		list($tagList_elements, $tagList_single) = $this->splitTagTypes($showTags);

#	debug(t3lib_parsehtml::checkTagTypeCounts($content,$tagList_elements, $tagList_single));
		
			// Fix l
[...]
 <pre>-tags if source
		if ($this->mode=='source')	{
			$content = '<pre>'.$content.'</pre>';
		}
		
		return $content;
	}

	";i:1;i:1;}s:12:"content_size";i:751;s:13:"content_lines";i:26;s:6:"atLine";i:203;}i:5;a:7:{s:6:"header";s:77:"function passthroughHTMLcontent($content,$relPathFix,$mode='',$altStyle='')	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:5:{s:4:"text";s:161:"

Passes through input HTML content string BUT substitutes relative paths. Used to format the parts of the file which are NOT marked up with markupHTMLcontent()
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:12:"HTML content";}i:1;a:2:{i:0;s:6:"string";i:1;s:201:"The relative path from module position back to the HTML-file position; used to correct paths of HTML since the HTML is modified so it can display correctly from the path of the module using this class.";}i:2;a:2:{i:0;s:6:"string";i:1;s:66:"The mode of display; [blank], explode, borders. Set in $this->mode";}i:3;a:2:{i:0;s:6:"string";i:1;s:79:"Alternative CSS style value from the style attribute of the <pre></pre>-section";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:13:"Modified HTML";}s:5:"other";a:1:{i:0;s:24:"@see markupHTMLcontent()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:20:"markupHTMLcontent() ";}}}s:7:"content";a:2:{i:0;s:407:"			// Fix links/paths
		if ($mode!='source')	{
			$content = $this->htmlParse->prefixResourcePath($relPathFix,$content);
		}
		
			// Wrap in <pre>-tags if source
		if ($mode=='source')	{
			$content = '<pre style="'.htmlspecialchars($altStyle?$altStyle:'font-size:11px; color:#999999; font-style:italic;').'">'.str_replace(chr(9),'    ',htmlspecialchars($content)).'</pre>';
		}
		
		return $content;
	}

	";i:1;i:0;}s:12:"content_size";i:407;s:13:"content_lines";i:13;s:6:"atLine";i:240;}i:7;a:7:{s:6:"header";s:54:"function getContentBasedOnPath($content,$pathStrArr)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:107:"

Returns content based on input $pathStrArray.	(an array with values which are paths to get out of HTML.)
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:28:"Input HTML to get path from.";}i:1;a:2:{i:0;s:6:"string";i:1;s:156:"The array where the values are paths, eg. array('td#content table[1] tr[1]','td#content table[1]','map#cdf / INNER') - takes only the first level in a path!";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:32:"Content... (not welldefined yet)";}}s:7:"content";a:2:{i:0;s:507:"			// INIT:
		$this->init();
		$this->searchPaths=array();
		$tagList = '';
		
		foreach($pathStrArr as $pathStr)	{
			list($pathInfo) = $this->splitPath($pathStr);
			$this->searchPaths[$pathInfo['path']] = $pathInfo;
			$tagList.=','.$pathInfo['tagList'];
		}

#		$tagList = implode(',',array_keys($this->tags));
		list($tagsBlock,$tagsSolo) = $this->splitTagTypes($tagList
[...]
hes' => array(md5($newBase), md5($content), md5($this->mergeSearchpartsIntoContent($newBase,$this->searchPaths))),
		);
	}

	";i:1;i:1;}s:12:"content_size";i:770;s:13:"content_lines";i:24;s:6:"atLine";i:261;}i:9;a:7:{s:6:"header";s:44:"function splitByPath($content,$pathString)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:13:"$content: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:16:"$pathString: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"		$outArray=array('',$content,'');
		if ($pathString)	{
			$pathInfo = $this->splitPath($pathString);
			foreach($pathInfo as $v)	{
				$contentP = $this->getContentBasedOnPath($outArray[1],array($v['fullpath']));
#debug(array($contentP,$v['path']));
				$pathExtract = $contentP['searchparts'][$v['path']];
				if (isset($pathExtract['placeholder']))	{
					$cSplit = explod
[...]
Extract['content'];
				} else return 'No placeholder found for path "'.$v['path'].'"...';
			}
		}
		return $outArray;
	}

	";i:1;i:1;}s:12:"content_size";i:660;s:13:"content_lines";i:19;s:6:"atLine";i:293;}i:11;a:7:{s:6:"header";s:70:"function splitContentToMappingInfo($fileContent,$currentMappingInfo)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:17:"$fileContent: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:24:"$currentMappingInfo: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"			// Get paths into an array
		$paths = $this->mappingInfoToSearchPath($currentMappingInfo);
#debug($paths);
			// Split content by the paths.
		$divContent = $this->getContentBasedOnPath($fileContent,$paths);
#debug($divContent);
			
			// Token for splitting the content further.
		$token = md5(microtime());
			
			// Replacing all placeholders with the keys from $curren
[...]
	}
		
#		debug(array(md5(implode('',$newArray['cArray'])),md5($fileContent)));
#		debug($newArray);
		return $newArray;
	}

	";i:1;i:1;}s:12:"content_size";i:1935;s:13:"content_lines";i:56;s:6:"atLine";i:320;}i:13;a:7:{s:6:"header";s:55:"function mappingInfoToSearchPath($currentMappingInfo)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:24:"$currentMappingInfo: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"		$paths = array();
		$pathsArrays = array();
		
			// Post processing, putting together all duplicate data in arrays which are easy to traverse in the next run.
		foreach($currentMappingInfo as $key => $val)	{
			if ($val['MAP_EL'])	{
				list($pathInfo) = $this->splitPath($val['MAP_EL']);
				$pathsArrays[$pathInfo['path']][$pathInfo['modifier']][]=$pathInfo['modifier_va
[...]
s[]=$k.' / RANGE:'.$v['RANGE'][0];
			} else	{
				$paths[]=$k;	// OUTER is default...
			}
			
		}
		
		return $paths;
	}

	";i:1;i:1;}s:12:"content_size";i:905;s:13:"content_lines";i:32;s:6:"atLine";i:383;}i:15;a:7:{s:6:"header";s:71:"function mergeSearchpartsIntoContent($content,$searchParts,$token='')	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:134:"

Substitutes all placeholders in $content string which are found in the $searchParts array (see syntax from getContentBasedOnPath())
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:27:"Content string with markers";}i:1;a:2:{i:0;s:5:"array";i:1;s:128:"Array with searchPaths which has been modified by $this->recursiveBlockSplitting in search mode to contain content and subparts.";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:11:"$token: ...";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:6:"HTML .";}}s:7:"content";a:2:{i:0;s:529:"		foreach($searchParts as $path => $pathInfo)	{
			if ($pathInfo['placeholder'])	{
				$content = str_replace(
					$pathInfo['placeholder'],
					$token?$token.$path.$pathInfo['modifier_lu'].$token:$pathInfo['content'],
					$content
				);
			}
			if (is_array($pathInfo['attr']))	{
				foreach($pathInfo['attr'] as $attrN => $pcPair)	{
					$content = str_replace(
						$pcPair['placeholder'],
						$token?$token.$path.'/ATTR:'.$attrN.$token:$pcPair['content'],
						$content
					);
				}
			}
		}
		return $content;
	}

	";i:1;i:0;}s:12:"content_size";i:529;s:13:"content_lines";i:21;s:6:"atLine";i:424;}i:17;a:7:{s:6:"header";s:123:"function mergeSampleDataIntoTemplateStructure($dataStruct,$currentMappingInfo,$firstLevelImplodeToken='',$sampleOrder='')	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:16:"$dataStruct: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:24:"$currentMappingInfo: ...";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:28:"$firstLevelImplodeToken: ...";}i:3;a:2:{i:0;s:6:"[type]";i:1;s:17:"$sampleOrder: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"	
		foreach($currentMappingInfo['cArray'] as $key => $val)	{
			if (!t3lib_div::testInt($key) && $dataStruct[$key])	{
				if ($dataStruct[$key]['type']=='array')	{
					if (is_array($currentMappingInfo['sub'][$key]))	{
						$currentMappingInfo['cArray'][$key]=$this->mergeSampleDataIntoTemplateStructure($dataStruct[$key]['el'],$currentMappingInfo['sub'][$key],'',
							($
[...]
ointer];
			}
		} else {
			$out = implode($firstLevelImplodeToken,$currentMappingInfo['cArray']);
		}
		return $out;
	
	}

	";i:1;i:1;}s:12:"content_size";i:1205;s:13:"content_lines";i:33;s:6:"atLine";i:455;}i:19;a:7:{s:6:"header";s:122:"function mergeFormDataIntoTemplateStructure($editStruct,$currentMappingInfo,$firstLevelImplodeToken='',$valueKey='vDEF')	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:16:"$editStruct: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:24:"$currentMappingInfo: ...";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:28:"$firstLevelImplodeToken: ...";}i:3;a:2:{i:0;s:6:"[type]";i:1;s:14:"$valueKey: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"		$isSection=0;
		if (is_array($editStruct))	{
			$testInt = implode('',array_keys($editStruct));
			$isSection = !ereg('[^0-9]',$testInt);
		}
		$out='';
		if ($isSection)	{
			foreach($editStruct as $section)	{
				$secKey = key($section);
				$secDat = $section[$secKey];
#debug(array($secKey,$secDat,$currentMappingInfo['sub']));
				if ($currentMappingInfo['sub'][$secKe
[...]
						}
					}
				}
				$out = implode($firstLevelImplodeToken,$currentMappingInfo['cArray']);
			}
		}
		return $out;
	}

	";i:1;i:1;}s:12:"content_size";i:1619;s:13:"content_lines";i:40;s:6:"atLine";i:498;}i:21;a:7:{s:6:"header";s:30:"function splitPath($pathStr)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:137:"

Processing of a path; It splits the path by tokens like "|", "/" and " " etc and returns an array with path-levels and properties etc.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:52:"The total path string to explode into smaller units.";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:34:"Array with the information inside.";}}s:7:"content";a:2:{i:0;s:507:"		$subPaths = t3lib_div::trimExplode('|',$pathStr,1);
		
		foreach($subPaths as $index => $path)	{
			$subPaths[$index]=array();
			$subPaths[$index]['fullpath'] = $path;

				// Get base parts of the page: the PATH and the COMMAND
			list($thePath,$theCmd) = t3lib_div::trimExplode('/', $path,1);
			
				// Split the path part into its units: results in an array with path 
[...]
 parent.
			$subPaths[$index]['parent'] = implode(' ',$splitParts);	// Cleaning up the path
		}
		
		return $subPaths;
	}
	
	";i:1;i:1;}s:12:"content_size";i:1689;s:13:"content_lines";i:49;s:6:"atLine";i:545;}i:23;a:7:{s:6:"header";s:38:"function getTemplateArrayForTO($uid)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:39:"

For use in both frontend and backend
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:9:"$uid: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:443:"		global $TCA;
		if (isset($TCA['tx_templavoila_tmplobj']))	{
			$query='SELECT * FROM tx_templavoila_tmplobj WHERE uid='.intval($uid).
					($TCA['tx_templavoila_tmplobj']['ctrl']['delete'] ? ' AND NOT '.$TCA['tx_templavoila_tmplobj']['ctrl']['delete'] : '');
			$res = mysql(TYPO3_db,$query);
			$row = mysql_fetch_assoc($res);
			$this->tDat = unserialize($row['templatemapping']);
			
			return $this->tDat['MappingData_cached'];
		}
	}

	";i:1;i:0;}s:12:"content_size";i:443;s:13:"content_lines";i:12;s:6:"atLine";i:601;}i:25;a:7:{s:6:"header";s:51:"function mergeDataArrayToTemplateArray($TA,$data)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:8:"$TA: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:10:"$data: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:192:"		if (is_array($TA['cArray']))	{
			foreach($data as $key => $value)	{
				if (isset($TA['cArray'][$key]))	$TA['cArray'][$key]=$value;
			}
			return implode('',$TA['cArray']);
		}
	}
	



	
	";i:1;i:0;}s:12:"content_size";i:192;s:13:"content_lines";i:12;s:6:"atLine";i:621;}i:27;a:7:{s:6:"header";s:54:"function getTemplateRecord($uid,$printFlag,$langUid)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:97:"

Returns the right template record for the current display
Requires the extension "TemplaVoila"
";s:5:"param";a:3:{i:0;a:2:{i:0;s:7:"integer";i:1;s:30:"The UID of the template record";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:15:"$printFlag: ...";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:13:"$langUid: ...";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:17:"The record array.";}}s:7:"content";a:2:{i:0;s:507:"		if (t3lib_extMgm::isLoaded('templavoila'))	{
			$rec = $GLOBALS['TSFE']->sys_page->checkRecord('tx_templavoila_tmplobj',$uid);
	
			if (is_array($rec))	{
				
				if ($printFlag)	{	// If print-flag try to find a proper print-record. If the lang-uid is also set, try to find a combined print/lang record, but if not found, the print rec. will take precedence.
						// Look 
[...]
sys_language_uid='.intval($langUid));
					if (is_array($printRow))	$rec = $printRow;
				}
			}
		
			return $rec;
		}
	}

	";i:1;i:1;}s:12:"content_size";i:1155;s:13:"content_lines";i:24;s:6:"atLine";i:643;}i:29;a:7:{s:6:"header";s:67:"function getTemplateMappingArray($uid,$printFlag,$langUid,$sheet)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:9:"$uid: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:15:"$printFlag: ...";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:13:"$langUid: ...";}i:3;a:2:{i:0;s:6:"[type]";i:1;s:11:"$sheet: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:208:"		$row = $this->getTemplateRecord($uid,$printFlag,$langUid);
		$tDat = unserialize($row['templatemapping']);
		return $sheet ? $tDat['MappingData_cached']['sub'][$sheet] : $tDat['MappingData_cached'];	
	}
	
	";i:1;i:0;}s:12:"content_size";i:208;s:13:"content_lines";i:5;s:6:"atLine";i:677;}i:31;a:7:{s:6:"header";s:47:"function getTemplateRecord_query($uid,$where)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:6:{s:4:"text";s:77:"

Helper function to build the query for searching print/language templates.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:7:"integer";i:1;s:30:"The UID of the template record";}i:1;a:2:{i:0;s:6:"string";i:1;s:17:"The where clause.";}}s:6:"return";a:2:{i:0;s:5:"mixed";i:1;s:45:"An array if a record is found, otherwise null";}s:6:"access";s:7:"private";s:5:"other";a:1:{i:0;s:24:"@see getTemplateRecord()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:20:"getTemplateRecord() ";}}}s:7:"content";a:2:{i:0;s:265:"		$query = 'SELECT * FROM tx_templavoila_tmplobj WHERE parent='.intval($uid).
				' '.$where.
				$GLOBALS['TSFE']->sys_page->enableFields('tx_templavoila_tmplobj');

		$res = mysql(TYPO3_db,$query);
		$printRow = mysql_fetch_assoc($res);
		return $printRow;
	}	

	";i:1;i:0;}s:12:"content_size";i:265;s:13:"content_lines";i:9;s:6:"atLine";i:692;}i:33;a:7:{s:6:"header";s:92:"function setHeaderBodyParts($MappingInfo_head,$MappingData_head_cached,$BodyTag_cached='')	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:52:"

Will set header content and BodyTag for template.
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:22:"$MappingInfo_head: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:29:"$MappingData_head_cached: ...";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:20:"$BodyTag_cached: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"	
			// Traversing mapped header parts:
		if (is_array($MappingInfo_head['headElementPaths']))	{
			foreach($MappingInfo_head['headElementPaths'] as $kk => $vv)	{
				if (isset($MappingData_head_cached['cArray']['el_'.$kk]))	{
					$uKey = md5(trim($MappingData_head_cached['cArray']['el_'.$kk]));
					$GLOBALS['TSFE']->additionalHeaderData['TV_'.$uKey] = chr(10).trim($Mapp
[...]
ched)	{
			$GLOBALS['TSFE']->defaultBodyTag = $BodyTag_cached;
		}
	}






	/**
	 * 
	 * Various sub processing
	 * 
	 */

	";i:1;i:1;}s:12:"content_size";i:629;s:13:"content_lines";i:28;s:6:"atLine";i:710;}i:35;a:8:{s:6:"header";s:17:"function init()	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:11:"sectionText";a:1:{i:0;s:22:"Various sub processing";}s:4:"cDat";a:3:{s:4:"text";s:121:"

Init function, should be called by the processing functions above before doing any recursive parsing of the HTML code.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:524:"			// HTML parser object initialized.
		$this->htmlParse = t3lib_div::makeInstance('t3lib_parsehtml');

			// Resetting element count array
		$this->elCountArray=array();
		$this->elParentLevel=array();

			// Setting gnyf style
		$style = '';
		$style.=(!t3lib_div::inList('explode,checkbox',$this->mode)?'position:absolute;':'');
#		$style.=($this->mode=='transparent'?'filter:alpha(Opacity=\'75\');':'');
#		$style.='border: 1px solid black;';
		$this->gnyfStyle = $style?' style="'.htmlspecialchars($style).'"':'';
	}

	";i:1;i:0;}s:12:"content_size";i:524;s:13:"content_lines";i:15;s:6:"atLine";i:744;}i:37;a:7:{s:6:"header";s:35:"function splitTagTypes($showTags)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:172:"

Takes the input list of tags to markup and validates it against $this->tags array.
Returns an array with two strings, the list of block tags and the list of single tags.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:66:"Comma list of tags, input to processing functions in top of class.";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:75:"array with two strings, the list of block tags and the list of single tags.";}}s:7:"content";a:2:{i:0;s:536:"		$showTagsArr = t3lib_div::trimExplode(',',strtolower($showTags),1);
		$showTagsArr = array_flip($showTagsArr);
		$tagList_elements = array();
		$tagList_single = array();

		foreach($this->tags as $tagname => $tagconfig)	{
			if (isset($showTagsArr[$tagname]))	{
				if ($tagconfig['single'])	{
					$tagList_single[]=$tagname;
				} else {
					$tagList_elements[]=$tagname;
				}
			}
		}
		
		return array(implode(',',$tagList_elements),implode(',',$tagList_single));
	}














	/**
	 * 
	 * SPLITTING functions
	 * 
	 */

	";i:1;i:0;}s:12:"content_size";i:536;s:13:"content_lines";i:37;s:6:"atLine";i:767;}i:39;a:8:{s:6:"header";s:93:"function recursiveBlockSplitting($content,$tagsBlock,$tagsSolo,$mode,$path='',$recursion=0)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:11:"sectionText";a:1:{i:0;s:19:"SPLITTING functions";}s:4:"cDat";a:3:{s:4:"text";s:361:"

Main splitting function - will split the input $content HTML string into sections based on the strings with tags, $tagsBlock and $tagsSolo
WARNING: No currect support for XML-ended tags, eg. <p/>. In fact there is not even support for block tags like <p> which does not have a counter part ending it!!! (This support must come from the htmlparser class btw.)
";s:5:"param";a:6:{i:0;a:2:{i:0;s:6:"string";i:1;s:22:"$content: HTML content";}i:1;a:2:{i:0;s:6:"string";i:1;s:124:"$tagsBlock: list of block tags; which has a start and end (eg. <p>...</p>, <table>...</table>, <tr>...</tr>, <div>...</div>)";}i:2;a:2:{i:0;s:6:"string";i:1;s:93:"$tagsSolo: list of solo (single) tags; which are stand-alone (eg. <img>, <br>, <hr>, <input>)";}i:3;a:2:{i:0;s:6:"string";i:1;s:175:"$mode: Denotes which mode of operation to apply: 'markup' will markup the html, 'search' will return HTML code with markers inserted for the found paths. Default does nothing.";}i:4;a:2:{i:0;s:6:"string";i:1;s:57:"$path: Used to accumulate the tags 'path' in the document";}i:5;a:2:{i:0;s:7:"integer";i:1;s:49:"$recursion: Used internally to control recursion.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:4:"HTML";}}s:7:"content";a:2:{i:0;s:507:"
			// Splitting HTML string by all block-tags
		$blocks = $this->htmlParse->splitIntoBlock($tagsBlock,$content,1);
		$this->rangeEndSearch[$recursion]='';
		$this->rangeStartPath[$recursion]='';

			// Traverse all sections of blocks
		foreach($blocks as $k=>$v) {	// INSIDE BLOCK: Processing of block content. This includes a recursive call to this function for the inner c
[...]
ode('',$soloParts);
				}
			}
			$blocks[$k]=$v;
		}
			// Implode and return all blocks
		return implode('',$blocks);
	}

	";i:1;i:1;}s:12:"content_size";i:3072;s:13:"content_lines";i:71;s:6:"atLine";i:817;}i:41;a:7:{s:6:"header";s:94:"function getMarkupCode($mode,$v,$params,$firstTagName,$firstTag,$endTag,$subPath,$recursion)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:151:"

In markup mode, this function is used to add the gnyf image to the HTML plus set all necessary attributes etc in order to mark up the code visually.
";s:5:"param";a:8:{i:0;a:2:{i:0;s:6:"string";i:1;s:39:"Element type: block or '' (single/solo)";}i:1;a:2:{i:0;s:6:"string";i:1;s:14:"Sub HTML code.";}i:2;a:2:{i:0;s:5:"array";i:1;s:29:"Attributes of the current tag";}i:3;a:2:{i:0;s:6:"string";i:1;s:29:"Current tags name (lowercase)";}i:4;a:2:{i:0;s:6:"string";i:1;s:17:"Current tag, full";}i:5;a:2:{i:0;s:6:"string";i:1;s:27:"End tag for the current tag";}i:6;a:2:{i:0;s:6:"string";i:1;s:23:"Current path of element";}i:7;a:2:{i:0;s:7:"integer";i:1;s:20:"The recursion number";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:27:"Modified sub HTML code ($v)";}}s:7:"content";a:2:{i:0;s:507:"	
			// Get gnyf:
		$attrInfo = '';
		if ($params[0]['class'])	$attrInfo.=' CLASS="'.$params[0]['class'].'"';
		if ($params[0]['id'])	$attrInfo.=' ID="'.$params[0]['id'].'"';
		$gnyf = $this->getGnyf($firstTagName,$subPath,$subPath.($attrInfo?' - '.$attrInfo:''));

		if ($mode=='block')	{
				// Disable A tags:
			if ($firstTagName=='a')	{
				$params[0]['onclick']='return
[...]
 $gnyf.$v;
			}
		}
			// return sub HTML code with the original tags wrapped around plus the gnyf inside.
		return $v;
	}

	";i:1;i:1;}s:12:"content_size";i:2565;s:13:"content_lines";i:70;s:6:"atLine";i:902;}i:43;a:7:{s:6:"header";s:100:"function getSearchCode($mode,$v,$params,$firstTagName,$firstTag,$endTag,$subPath,$path,$recursion)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:64:"

In search mode, this function is used to process the content.
";s:5:"param";a:9:{i:0;a:2:{i:0;s:6:"string";i:1;s:39:"Element type: block or '' (single/solo)";}i:1;a:2:{i:0;s:6:"string";i:1;s:14:"Sub HTML code.";}i:2;a:2:{i:0;s:5:"array";i:1;s:29:"Attributes of the current tag";}i:3;a:2:{i:0;s:6:"string";i:1;s:29:"Current tags name (lowercase)";}i:4;a:2:{i:0;s:6:"string";i:1;s:17:"Current tag, full";}i:5;a:2:{i:0;s:6:"string";i:1;s:27:"End tag for the current tag";}i:6;a:2:{i:0;s:6:"string";i:1;s:23:"Current path of element";}i:7;a:2:{i:0;s:7:"integer";i:1;s:20:"The recursion number";}i:8;a:2:{i:0;s:6:"[type]";i:1;s:15:"$recursion: ...";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:27:"Modified sub HTML code ($v)";}}s:7:"content";a:2:{i:0;s:507:"		if ($this->rangeEndSearch[$recursion])	{
			$this->searchPaths[$this->rangeStartPath[$recursion]]['content'].=$firstTag.$v.$endTag;
			$v = '';

			if ($this->rangeEndSearch[$recursion] == $subPath)	{
				$this->searchPaths[$this->rangeStartPath[$recursion]]['closed']=1;
				$this->rangeEndSearch[$recursion]='';
				$this->rangeStartPath[$recursion]='';
			}
		} elseif (
[...]
$firstTag.$v.$endTag;
					$v = $placeholder;
				break;
			}
		} else {
			$v = $firstTag.$v.$endTag;
		}
		return $v;
	}

	";i:1;i:1;}s:12:"content_size";i:2652;s:13:"content_lines";i:73;s:6:"atLine";i:987;}i:45;a:7:{s:6:"header";s:62:"function sourceDisplay($str,$recursion,$gnyf='',$valueStr=0)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:52:"

Will format content for display in 'source' mode.
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:23:"Input string to format.";}i:1;a:2:{i:0;s:7:"integer";i:1;s:48:"The recursion integer - used to indent the code.";}i:2;a:2:{i:0;s:6:"string";i:1;s:26:"The gnyf-image to display.";}i:3;a:2:{i:0;s:7:"boolean";i:1;s:127:"If set, then the line will be formatted in color as a "value" (means outside of the tag which might otherwise be what is shown)";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:16:"Formatted input.";}}s:7:"content";a:2:{i:0;s:325:"		if (strcmp(trim($str),''))	{
			return str_pad('',$recursion*2,' ',STR_PAD_LEFT).
				$gnyf.
				($valueStr ? '<font color="#6666FF"><em>' : '').
				htmlspecialchars(t3lib_div::fixed_lgd(ereg_replace('[[:space:]]+',' ',$str),$this->maxLineLengthInSourceMode)).
				($valueStr ? '</em></font>' : '').
				chr(10);
		}
	}

	";i:1;i:0;}s:12:"content_size";i:325;s:13:"content_lines";i:10;s:6:"atLine";i:1070;}i:47;a:7:{s:6:"header";s:70:"function checkboxDisplay($str,$recursion,$path,$gnyf='',$valueStr=0)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:54:"

Will format content for display in 'checkbox' mode.
";s:5:"param";a:5:{i:0;a:2:{i:0;s:6:"string";i:1;s:23:"Input string to format.";}i:1;a:2:{i:0;s:7:"integer";i:1;s:48:"The recursion integer - used to indent the code.";}i:2;a:2:{i:0;s:6:"string";i:1;s:9:"HTML path";}i:3;a:2:{i:0;s:6:"string";i:1;s:26:"The gnyf-image to display.";}i:4;a:2:{i:0;s:7:"boolean";i:1;s:127:"If set, then the line will be formatted in color as a "value" (means outside of the tag which might otherwise be what is shown)";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:16:"Formatted input.";}}s:7:"content";a:2:{i:0;s:505:"		if ($valueStr)	{
			return trim($str) ? '
				<tr class="bgColor4">
					<td>&nbsp;</td>
					<td>&nbsp;</td>
					<td>'.$this->passthroughHTMLcontent(trim($str),'','source').'</td>
				</tr>' : '';
		} else {
			return '
				<tr class="bgColor4">
					<td><input type="checkbox" name="checkboxElement[]" value="'.$path.'"'.(in_array($path,$this->checkboxPathsSet)?' checked="checked"':'').' /></td>
					<td>'.$gnyf.'</td>
					<td><pre>'.trim(htmlspecialchars($str)).'</pre></td>
				</tr>';
		}
	}

	";i:1;i:0;}s:12:"content_size";i:505;s:13:"content_lines";i:17;s:6:"atLine";i:1091;}i:49;a:4:{s:6:"header";s:46:"function makePath($path,$firstTagName,$attr)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:69:"

Compile the path value for the current path/tagname and attributes
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:41:"Current path string for the parent level.";}i:1;a:2:{i:0;s:6:"string";i:1;s:50:"The tag name for the current element on that level";}i:2;a:2:{i:0;s:6:"string";i:1;s:59:"The attributes for the tag in an array with key/value pairs";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:13:"The sub path.";}}s:6:"atLine";i:1117;}i:51;a:7:{s:6:"header";s:46:"function getGnyf($firstTagName,$path,$title)	{";s:11:"parentClass";s:25:"tx_templavoila_htmlmarkup";s:4:"cDat";a:3:{s:4:"text";s:37:"

Returns the GNYF image (tag-image)
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:46:"The tag name in lowercase, eg. "table" or "tr"";}i:1;a:2:{i:0;s:6:"string";i:1;s:58:"Path string for the link and title-attribute of the image.";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:11:"$title: ...";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:4:"HTML";}}s:7:"content";a:2:{i:0;s:507:"		if (!$this->onlyElements || t3lib_div::inList($this->onlyElements,$firstTagName))	{
			$gnyf= '<img '.str_replace('###PATH###',$this->pathPrefix.$path,$this->gnyfImgAdd).' src="'.$this->gnyfPath.'html_tags/'.$firstTagName.'.gif" border="0" title="'.htmlspecialchars($title).'"'.$this->gnyfStyle.' alt="" />'.
						($this->mode=='explode' ? '<br />' : '');
			return $gnyf;
[...]
.php'])	{
	include_once($TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/class.tx_templavoila_htmlmarkup.php']);
}
?>
";i:1;i:1;}s:12:"content_size";i:627;s:13:"content_lines";i:12;s:6:"atLine";i:1145;}}}s:14:"MD5_005a2bcadc";a:4:{s:8:"filename";s:30:"class.tx_templavoila_rules.php";s:8:"filesize";i:30517;s:6:"header";a:5:{s:4:"text";s:510:"

Class 'tx_templavoila_rules' for the 'templavoila' extension.

This library contains several functions for evaluating and output of rules
being defined in data structure objects.

NOTE: This class follows the SINGLETON pattern which is one of several design patterns for object
oriented software programming. That means that you mustn't create an instance of this class on
your own but call the method tx_templavoila_rules::getInstance instead. This will make sure that
this class is only instanciated once.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:41:"@author		Robert Lemke <rl@robertlemke.de>";i:1;s:15:"@package		TYPO3";i:2;s:26:"@subpackage	tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:32:"Robert Lemke <rl@robertlemke.de>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:22:{i:1;a:8:{s:6:"header";s:28:"class tx_templavoila_rules {";s:5:"class";i:1;s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:5:{s:4:"text";s:510:"

Class 'tx_templavoila_rules' for the 'templavoila' extension.

This library contains several functions for evaluating and output of rules
being defined in data structure objects.

NOTE: This class follows the SINGLETON pattern which is one of several design patterns for object
oriented software programming. That means that you mustn't create an instance of this class on
your own but call the method tx_templavoila_rules::getInstance instead. This will make sure that
this class is only instanciated once.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:41:"@author		Robert Lemke <rl@robertlemke.de>";i:1;s:15:"@package		TYPO3";i:2;s:26:"@subpackage	tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:32:"Robert Lemke <rl@robertlemke.de>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:7:"content";a:2:{i:0;s:171:"	var $lastParsedRecord;	// Holds the last child record before an error occurs. Used for rule tracking / err messages
	var $currentFieldName;	// Used for error tracking
	
	";i:1;i:-1;}s:12:"content_size";i:171;s:13:"content_lines";i:3;s:6:"atLine";i:85;}i:3;a:7:{s:6:"header";s:25:"function getInstance()  {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:4:{s:4:"text";s:221:"

This function returns an instance of this rules class. Always use this function in order
to create / get an instance of this class, don't instantiate it yourself. This will make
sure, only one instance exists globally.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"object";i:1;s:25:"An instance of this class";}s:6:"access";s:6:"public";}s:7:"content";a:2:{i:0;s:143:"		static $instance;
		if (!isset ($instance)) {
			$instance = t3lib_div::makeInstance ('tx_templavoila_rules');
		}
		return $instance;
	}
	
	";i:1;i:0;}s:12:"content_size";i:143;s:13:"content_lines";i:7;s:6:"atLine";i:97;}i:5;a:7:{s:6:"header";s:49:"function evaluateRulesForElement ($table, $uid) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:6:{s:4:"text";s:408:"

Checks a given element if it complies with certain rules provided as a regular expression.
This function prepares all the information which is needed to check rules compliance, the
check itself will be carried out by checkRulesForElement () which calls itself recursively.

Note that only few functionality of the POSIX standard for regular expressions is being supported,
see the manual for more details.
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:191:"$rules: A regular expression describing the rule. The content elements are reflected by certain tokens (i.e. uppercase and lowercase characters). These tokens are also called "ruleConstants".";}i:1;a:2:{i:0;s:5:"array";i:1;s:72:"$ruleConstants: An array with the mapping of tokens to content elements.";}i:2;a:2:{i:0;s:5:"array";i:1;s:9:"$elArray:";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:64:"Array containing status information if the check was successful.";}s:6:"access";s:6:"public";s:5:"other";a:1:{i:0;s:27:"@see checkRulesForElement()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:23:"checkRulesForElement() ";}}}s:7:"content";a:2:{i:0;s:507:"	 	$statusArr = array();
	 	
			// Getting data structure for the template and extract information for default records to create
		$parentRecord = t3lib_BEfunc::getRecord ($table, $uid);

			// Only care about page records or flexible content elements:
		if ($table != 'tt_content' || $parentRecord['CType'] == 'templavoila_pi1') {	
			$recRow = t3lib_BEfunc::getRecord ('tx_
[...]
**********************
	 *	
	 *  Rule processing / analyzing functions
	 *
	 ********************************************/

	";i:1;i:1;}s:12:"content_size";i:2107;s:13:"content_lines";i:47;s:6:"atLine";i:120;}i:7;a:8:{s:6:"header";s:66:"function checkRulesForElement($rules, $constants, $childRecords) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:11:"sectionText";a:1:{i:0;s:37:"Rule processing / analyzing functions";}s:4:"cDat";a:4:{s:4:"text";s:80:"

Checks the child records of an element for compliance to the element's rules.
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:122:"$rules: The regular expression as a string OR the regular expression already parsed into an array (by parseRegexIntoArray)";}i:1;a:2:{i:0;s:6:"string";i:1;s:111:"$constants: The constants definitions being used in the regular expression divided by line breaks (eg.: a=text)";}i:2;a:2:{i:0;s:5:"array";i:1;s:73:"$childRecords: Array of child records (normally page and tt_content rows)";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:71:"The status array containing information about errors, restrictions etc.";}s:6:"access";s:7:"private";}s:7:"content";a:2:{i:0;s:507:"		global $LANG;

		if (!is_array ($childRecords)) { return array ('ok'=>false); }
		$statusArr = array ('ok' => true);
		
		if (is_string ($rules)) {	// If $rules is a regular expression, parse it into an array for easier handling:
				// Strip off the starting and ending delimiter
			if ($rules[0]=='^') { $rules = substr ($rules, 1); }
			if ($rules[strlen($rules)-1]=='$'
[...]
ords as $childRecord) {
					$this->statusAddErr($statusArr, '', $childRecord,1);
				}
			}
		}		
		return $statusArr;
	}

	";i:1;i:1;}s:12:"content_size";i:1515;s:13:"content_lines";i:35;s:6:"atLine";i:177;}i:9;a:7:{s:6:"header";s:80:"function checkRulesForElement_parseEL ($rulePart, &$childRecords, &$statusArr) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:4:{s:4:"text";s:55:"

Validates an element, used by checkRulesForElement()
";s:5:"param";a:3:{i:0;a:2:{i:0;s:5:"array";i:1;s:90:"$rulePart: part of the regular expression parsed into an array containing the 'el' branch.";}i:1;a:2:{i:0;s:5:"array";i:1;s:116:"$childRecords: Current array of child records of the main element which remain to be processed. Passed by reference!";}i:2;a:2:{i:0;s:5:"array";i:1;s:57:"$statusArr: The current status array, passed by reference";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:34:"Results are returned by reference.";}s:6:"access";s:7:"private";}s:7:"content";a:2:{i:0;s:517:"		$counter = 0;
		while ($counter < $rulePart['max'] && ($childRecords[0]['CType'] == $rulePart['el'] || $rulePart['el'] == '.')) {
			$tmp = array_shift($childRecords);
			if (is_array ($tmp)) {
				$this->lastParsedRecord = $tmp;
			} else {
				break;
			}
			$counter ++;
		}
		if ($counter < $rulePart['min']) { 
			$msg = 'At least '.$rulePart['min'].' element(s) of type '.$rulePart['el'].' expected, only '.$counter.' were found';
			$this->statusAddErr($statusArr, $msg, $this->lastParsedRecord,2);
		}
	}

	";i:1;i:0;}s:12:"content_size";i:517;s:13:"content_lines";i:16;s:6:"atLine";i:222;}i:11;a:7:{s:6:"header";s:93:"function checkRulesForElement_parseSUB ($rulePart, &$childRecords, &$statusArr, $constants) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:6:{s:4:"text";s:54:"

Validates a subpart, used by checkRulesForElement()
";s:5:"param";a:7:{i:0;a:2:{i:0;s:5:"array";i:1;s:91:"$rulePart: part of the regular expression parsed into an array containing the 'sub' branch.";}i:1;a:2:{i:0;s:5:"array";i:1;s:116:"$childRecords: Current array of child records of the main element which remain to be processed. Passed by reference!";}i:2;a:2:{i:0;s:5:"array";i:1;s:57:"$statusArr: The current status array, passed by reference";}i:3;a:2:{i:0;s:6:"string";i:1;s:45:"$constants: The regular expresion's constants";}i:4;a:2:{i:0;s:6:"string";i:1;s:51:"$table: table for the current parent element record";}i:5;a:2:{i:0;s:7:"integer";i:1;s:45:"$uid: ID of the current parent element record";}i:6;a:2:{i:0;s:6:"string";i:1;s:43:"$field: Field name within the datastructure";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:34:"Results are returned by reference.";}s:6:"access";s:7:"private";s:5:"other";a:1:{i:0;s:34:"@todo				Not completely tested yet";}s:11:"other_index";a:1:{s:5:"@todo";a:1:{i:0;s:25:"Not completely tested yet";}}}s:7:"content";a:2:{i:0;s:507:"#debug ($rulePart, 'rulePart: SUB', __LINE__, __FILE__);
		if (is_array ($rulePart['sub'])) {
			for ($counter=1; $counter <= $rulePart['max']; $counter++) {
				$savedChildren = $childRecords;
				$savedStatus = $tmpStatusArr;
#debug ($savedChildren, 'SAVEDCHILDREN');
				foreach ($rulePart['sub'] as $k => $ruleSubPart) {
#debug (array ('ruleSubPart'=>$ruleSubPart,'counte
[...]
ug ($childRecords,'childRecords in parseSub',__LINE__,__FILE__,10);

#		$this->statusMerge ($statusArr, $tmpStatusArr);
	}

	";i:1;i:1;}s:12:"content_size";i:1947;s:13:"content_lines";i:41;s:6:"atLine";i:253;}i:13;a:7:{s:6:"header";s:93:"function checkRulesForElement_parseALT ($rulePart, &$childRecords, &$statusArr, $constants) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:4:{s:4:"text";s:64:"

Validates an alternative part, used by checkRulesForElement()
";s:5:"param";a:7:{i:0;a:2:{i:0;s:5:"array";i:1;s:91:"$rulePart: part of the regular expression parsed into an array containing the 'alt' branch.";}i:1;a:2:{i:0;s:5:"array";i:1;s:116:"$childRecords: Current array of child records of the main element which remain to be processed. Passed by reference!";}i:2;a:2:{i:0;s:5:"array";i:1;s:57:"$statusArr: The current status array, passed by reference";}i:3;a:2:{i:0;s:6:"string";i:1;s:45:"$constants: The regular expresion's constants";}i:4;a:2:{i:0;s:6:"string";i:1;s:51:"$table: table for the current parent element record";}i:5;a:2:{i:0;s:7:"integer";i:1;s:45:"$uid: ID of the current parent element record";}i:6;a:2:{i:0;s:6:"string";i:1;s:43:"$field: Field name within the datastructure";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:34:"Results are returned by reference.";}s:6:"access";s:7:"private";}s:7:"content";a:2:{i:0;s:507:"		$altStatusArr = array ();						
		foreach ($rulePart['alt'] as $alternativeRule) {
			$tmpStatusArr = $this->checkRulesForElement($alternativeRule, $constants, $childRecords);
			if ($tmpStatusArr['ok'] !== false) { // If one alternative is okay, the whole ALT branch is valid
				$this->statusSetOK ($altStatusArr);
				break;
			} elseif ($tmpStatusArr['ok'] === false) {
[...]
; 
		}
			// After an ALT branch no other elements will follow, so clear all remaining children
		$childRecords = null;
	}

	";i:1;i:1;}s:12:"content_size";i:827;s:13:"content_lines";i:19;s:6:"atLine";i:308;}i:15;a:7:{s:6:"header";s:83:"function checkRulesForElement_parseCLASS ($rulePart, &$childRecords, &$statusArr) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:6:{s:4:"text";s:64:"

Validates a class of elements, used by checkRulesForElement()
";s:5:"param";a:3:{i:0;a:2:{i:0;s:5:"array";i:1;s:93:"$rulePart: part of the regular expression parsed into an array containing the 'class' branch.";}i:1;a:2:{i:0;s:5:"array";i:1;s:116:"$childRecords: Current array of child records of the main element which remain to be processed. Passed by reference!";}i:2;a:2:{i:0;s:5:"array";i:1;s:57:"$statusArr: The current status array, passed by reference";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:34:"Results are returned by reference.";}s:6:"access";s:7:"private";s:5:"other";a:1:{i:0;s:49:"@todo				Obviously this function does nothing yet";}s:11:"other_index";a:1:{s:5:"@todo";a:1:{i:0;s:40:"Obviously this function does nothing yet";}}}s:7:"content";a:2:{i:0;s:339:"#debug (array ('rulePart'=>$rulePart['class']), 'rulePart: CLASS', __LINE__, __FILE__);
	}

	
	
	
	
	/********************************************
	 *	
	 * Human Readable Rules Functions
	 *
	 * NOTE: This section is not working yet and
	 *       has rather an experimental character
	 *
	 ********************************************/
	
	";i:1;i:0;}s:12:"content_size";i:339;s:13:"content_lines";i:16;s:6:"atLine";i:338;}i:17;a:8:{s:6:"header";s:56:"function getHumanReadableRules ($rules,$ruleConstants)	{";s:11:"parentClass";s:20:"tx_templavoila_rules";s:11:"sectionText";a:3:{i:0;s:30:"Human Readable Rules Functions";i:1;s:41:"NOTE: This section is not working yet and";i:2;s:36:"has rather an experimental character";}s:4:"cDat";a:3:{s:4:"text";s:52:"

Returns a description of a rule in human language
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:46:"$rules: Regular expression containing the rule";}i:1;a:2:{i:0;s:5:"array";i:1;s:58:"$ruleConstants: Contains the mapping of elements to CTypes";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:23:"Description of the rule";}}s:7:"content";a:2:{i:0;s:180:"		$rulesArr = $this->parseRegexIntoArray ($rules);
//		$constantsArr = $this->

#debug ($rulesArr);
		return $this->parseRulesArrayIntoDescription ($rulesArr, $constantsArr);
	}

	";i:1;i:0;}s:12:"content_size";i:180;s:13:"content_lines";i:7;s:6:"atLine";i:362;}i:19;a:7:{s:6:"header";s:78:"function parseRulesArrayIntoDescription ($rulesArr, $constantsArr, $level=0) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:14:"$rulesArr: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:18:"$constantsArr: ...";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:11:"$level: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"		if (is_array ($rulesArr)) {
			foreach ($rulesArr as $k=>$v) {
				if (is_array ($v['alt'])) {
					reset ($v['alt']);
					if (count ($v['alt'])>1) { $description .= 'either '; }
					for ($i=0; $i <= count ($v['alt']); $i++) {
						list ($k,$vAlt) = each ($v['alt']);
						$description .= $this->getHumanReadableRules ($vAlt, $ruleConstants, $level+1);
						if ($i < c
[...]
cription .= $this->getElementNameFromConstantsMapping ($v['el'], $constantsArr);
				}
			}
		}

		return $description;
	}

	";i:1;i:1;}s:12:"content_size";i:963;s:13:"content_lines";i:27;s:6:"atLine";i:378;}i:21;a:7:{s:6:"header";s:50:"function getQuantifierAsDescription ($min, $max) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:9:"$min: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:9:"$max: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:507:"		if ($min == $max) {
			switch ($min) {
				case 1:		$description = 'one ';
							break;
				case 0:		$description = 'no ';
							break;
				case 999:	$description = 'any number of ';
							break;
				default:	$description = intval ($min).' times ';
							break;
			}
		} elseif ($min == 0) {
			switch ($max) {
				case 1:		$description = 'maybe one '; break;
				case 
[...]

			}
		} elseif ($min > 0) {
			switch ($max) {
				case 999:	$description =''; break;
			}
		}
		return $description;
	}

	";i:1;i:1;}s:12:"content_size";i:607;s:13:"content_lines";i:25;s:6:"atLine";i:413;}i:23;a:7:{s:6:"header";s:71:"function getElementNameFromConstantsMapping ($element, $constantsArr) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:13:"$element: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:18:"$constantsArr: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:293:"		switch ($element) {
			case '.' :
				$description = 'any element ';
				break;
			default:
				$description = $element.' ';
		}
		return $description;
	}

	
	
	
	
	/********************************************
	 *	
	 * Helper functions
	 *
	 ********************************************/

	";i:1;i:0;}s:12:"content_size";i:293;s:13:"content_lines";i:20;s:6:"atLine";i:446;}i:25;a:8:{s:6:"header";s:51:"function parseRegexIntoArray ($regex, $constants) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:11:"sectionText";a:1:{i:0;s:16:"Helper functions";}s:4:"cDat";a:3:{s:4:"text";s:77:"

Parses a regular expression with a reduced set of functions into an array.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:30:"$regex: The regular expression";}i:1;a:2:{i:0;s:6:"string";i:1;s:111:"$constants: The constants definitions being used in the regular expression divided by line breaks (eg.: a=text)";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:52:"Contains the cTypes with some additional information";}}s:7:"content";a:2:{i:0;s:507:"		$pos = 0;
		$outArr = array ();
			// Strip off the not wanted characters. We only support certain functions of regular expressions.
		$regex = ereg_replace ('[^a-zA-Z0-9\[\]\{\}\*\+\.\-]','',$regex);

			// Split regular expression into alternative parts divided by '|'. If there is more then one part,
			// call this function recursively and parse each part separately.

[...]
g ('Parse error: At least one element expected in class definition'); }
				}
				$pos++;
			}
		}
		return $outArr;
	}	
		
	";i:1;i:1;}s:12:"content_size";i:2458;s:13:"content_lines";i:70;s:6:"atLine";i:474;}i:27;a:7:{s:6:"header";s:28:"function isElement ($char) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:52:"

Returns true if the given character is an element
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:30:"$char: Character to be checked";}}s:6:"return";a:2:{i:0;s:7:"boolean";i:1;s:24:"true if it is an element";}}s:7:"content";a:2:{i:0;s:99:"		return ((strtoupper($char[0]) >= 'A' && strtoupper($char[0]) <= 'Z') || ($char[0]) == '.');
	}

	";i:1;i:0;}s:12:"content_size";i:99;s:13:"content_lines";i:3;s:6:"atLine";i:551;}i:29;a:7:{s:6:"header";s:48:"function extractInnerBrace ($regex, $startPos) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:6:{s:4:"text";s:268:"

Parses a given string for braces () and returns an array which contains the inner part of theses braces
as well as the remaining right after the braces. If there is a quantifier after the closing brace, it will
be evaluated and returned in the result array as well.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:30:"$regex: The regular expression";}i:1;a:2:{i:0;s:7:"integer";i:1;s:77:"$startPos: The position within the regex string where the search should start";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:43:"Array containing the results (see function)";}s:6:"access";s:7:"private";s:5:"other";a:1:{i:0;s:31:"@see					parseRegexIntoArray ()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:22:"parseRegexIntoArray ()";}}}s:7:"content";a:2:{i:0;s:507:"		for ($endPos=$startPos; $endPos<strlen ($regex); $endPos++) { 
			if ($regex[$endPos]=='(') { 
				$level++;				
			}
			if ($regex[$endPos]==')') {
				if ($level == 1) {
						// The end of the inner part, point to one char after the closing brace
						// Get the min and max from a quantifier which might be there
					$savePos = $endPos;
					$this->evaluateQuantifier
[...]
str ($regex,$endPos+2);
		return array ('content' => $innerBrace, 'min' => $min, 'max'=>$max, 'rightpart'=>$rightPart);
	}

	";i:1;i:1;}s:12:"content_size";i:719;s:13:"content_lines";i:22;s:6:"atLine";i:566;}i:31;a:7:{s:6:"header";s:39:"function explodeAlternatives ($regex) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:118:"

Explodes a regular expression into an array of alternatives which were separated by '|'.
Takes braces into account.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:43:"$regex: The regular expression to be parsed";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:21:"The alternative parts";}}s:7:"content";a:2:{i:0;s:272:"		for ($pos=0; $pos<strlen($regex); $pos++) {
			if ($regex[$pos]=='(') { 
				$level++;				
			}
			if ($regex[$pos]==')' && $level>0) {
				$level--;
			}
			if ($regex[$pos]=='|' && $level==0) {
				$regex[$pos]= chr(1);
			}
		}
		return explode (chr(1),$regex);
	}

	";i:1;i:0;}s:12:"content_size";i:272;s:13:"content_lines";i:14;s:6:"atLine";i:596;}i:33;a:7:{s:6:"header";s:64:"function evaluateQuantifier ($quantifier, &$pos, &$min, &$max) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:263:"

Looks for a quantifier and returns their minimum and maximum values. Note that the position parameter
is passed by reference. It will be incremented depending on the length of the quantify expression.
The results for min and max are also returned by reference!
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:70:"$quantifier: The regular expression which likely contains a quantifier";}i:1;a:2:{i:0;s:7:"integer";i:1;s:81:"$pos: The position within the string where the quantifier should be. BY REFERENCE";}i:2;a:2:{i:0;s:7:"integer";i:1;s:101:"$min: Used for returning the minimum value, ie. how many times an element should be repeated at least";}i:3;a:2:{i:0;s:7:"integer";i:1;s:103:"$max: Used for returning the maximum value, ie. how many times an element should be repeated at maximum";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"		$min=1;
		$max=1;
		if (!$quantifier[$pos+1]) { return; }
		if (strpos (' *?+{',$quantifier[$pos+1])) {
			switch ($quantifier[$pos+1]) {
				case '*':	
					$min = 0; 
					$max = 999;	 // Indefinately
					break;
				case '?':	
					$min = 0;
					$max = 1;
					break;
				case '+':	
					$min = 1;
					$max = 999; // Indefinately
					break;
				case '{':		// Quantifi
[...]
}
					break;
				default:
					debug ('Parse error! Unexpected token: \''.$quantifier[$pos+1].'\''); $ok = 0;
			}
		}
	}

	";i:1;i:1;}s:12:"content_size";i:1317;s:13:"content_lines";i:50;s:6:"atLine";i:622;}i:35;a:7:{s:6:"header";s:53:"function getCTypeFromToken ($token, $ruleConstants) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:85:"

Returns the CType (fx. 'text' or 'imgtext') for a given constant (fx. 'a' or 'c').
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:48:"$token: The constant / token, a single character";}i:1;a:2:{i:0;s:6:"string";i:1;s:115:"$ruleConstants: The constants definitions being used in the regular expression divided by line breaks (eg.: a=text)";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:20:"The constant's CType";}}s:7:"content";a:2:{i:0;s:468:"		if ($token == '.') { return $token; }
		
		$lines = explode (chr(10), $ruleConstants);
		if (is_array ($lines)) {
			foreach ($lines as $line) {
				if (ord ($line[0]) > 13) {	// Ignore empty lines
					$parts = t3lib_div::trimExplode('=',$line);
					$constArr[$parts[0]]=$parts[1];
				}
			}
		}
		return $constArr[$token];
	}

	
	
	
	
	/********************************************
	 *	
	 * Status functions
	 *
	 ********************************************/

	";i:1;i:0;}s:12:"content_size";i:468;s:13:"content_lines";i:24;s:6:"atLine";i:680;}i:37;a:8:{s:6:"header";s:83:"function statusAddErr (&$statusArr, $msg, $lastParsedRecord=array(), $position=0) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:11:"sectionText";a:1:{i:0;s:16:"Status functions";}s:4:"cDat";a:3:{s:4:"text";s:79:"

Adds an error message to the status array. The array is passed by reference!
";s:5:"param";a:4:{i:0;a:2:{i:0;s:5:"array";i:1;s:49:"$$statusArr: A status array, passed by reference.";}i:1;a:2:{i:0;s:6:"string";i:1;s:23:"$msg: The error message";}i:2;a:2:{i:0;s:7:"integer";i:1;s:100:"$lastParsedRecord: Record the element causing the error or being next to it. Optional but important.";}i:3;a:2:{i:0;s:7:"integer";i:1;s:141:"$position: 0: element #uid causes the error, -1: an element before #uid cause the error, 1: an element after #uid, 2: all elements after #uid";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:47:"Nothing returned, result is passed by reference";}}s:7:"content";a:2:{i:0;s:203:"		$statusArr['ok'] = false;
		$statusArr['error'][] = array (
			'message' => $msg,
			'uid' => $lastParsedRecord['uid'],
			'fieldname' => $this->currentFieldName,
			'position' => $position,
		);
	}

	";i:1;i:0;}s:12:"content_size";i:203;s:13:"content_lines";i:9;s:6:"atLine";i:714;}i:39;a:7:{s:6:"header";s:65:"function statusMerge (&$statusArr, $newStatusArr, $doAND=false) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:69:"

Merges two status arrays, the second array overrules the first one
";s:5:"param";a:3:{i:0;a:2:{i:0;s:5:"array";i:1;s:80:"$statusArr: A status array, passed by reference. Will contain the merged arrays.";}i:1;a:2:{i:0;s:5:"array";i:1;s:59:"$newStatusArr: The second status array overruling the first";}i:2;a:2:{i:0;s:7:"boolean";i:1;s:81:"$doAND: If set, the 'ok' status will be evaluated by performing an AND operation.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:17:"Nothing returned.";}}s:7:"content";a:2:{i:0;s:507:"		if (is_array ($statusArr) && count ($statusArr)) {
#debug (array ('statusArr'=>$statusArr, 'newStatusArr' => $newStatusArr, 'doAND'=>$doAND, 'ANDed'=>($oldOK && $newStatusArr['ok'])),'statusMerge',__LINE__);
			if (is_array ($statusArr['error']) && is_array ($newStatusArr['error'])) {
				$statusArr['error'] = array_merge($statusArr['error'], $newStatusArr['error']);
			
[...]
		}
				$statusArr['ok'] = $statusArr['ok'] && $newStatusArr['ok'];
			}
		} else {
			$statusArr = $newStatusArr;	
		}
	}

	";i:1;i:1;}s:12:"content_size";i:825;s:13:"content_lines";i:19;s:6:"atLine";i:732;}i:41;a:4:{s:6:"header";s:36:"function statusSetOK (&$statusArr) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:93:"

Clears any errors and sets the status to "valid". The status array is passed by reference.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:5:"array";i:1;s:49:"&$statusArr: A status array, passed by reference.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:8:"Nothing.";}}s:6:"atLine";i:758;}i:43;a:7:{s:6:"header";s:72:"function statusSetELRestrictions (&$statusArr, $uid, $restrictionsArr) {";s:11:"parentClass";s:20:"tx_templavoila_rules";s:4:"cDat";a:3:{s:4:"text";s:526:"

NOTE: This is not active yet

Adds information about restrictions of a content element (regarding the current rules) to the status array.
Restriction means, what type of CE may or may not be added after this element, if the element may be deleted etc.

Options for the restrictionsArr:
'allowedElementsAfter' =>  List of CE types which are allowed after this element. If false, no element is allowed, if not set, any element is allowed
'required' => If set to true, this element is required an therefore must not be deleted
";s:5:"param";a:3:{i:0;a:2:{i:0;s:5:"array";i:1;s:49:"&$statusArr: A status array, passed by reference.";}i:1;a:2:{i:0;s:5:"array";i:1;s:126:"$restrictionsArr: Array containing restrictions which apply to this element see description of this function for valid options";}i:2;a:2:{i:0;s:7:"integer";i:1;s:29:"$uid: The content element uid";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:145:"		$statusArr['restrictions'][$uid] = t3lib_div::array_merge_recursive_overrule ($statusArr['restrictions'][$uid], $restrictionsArr, 0);
	}
}

?>
";i:1;i:0;}s:12:"content_size";i:145;s:13:"content_lines";i:5;s:6:"atLine";i:778;}}}s:14:"MD5_ae0ea69cd3";a:4:{s:8:"filename";s:13:"cm1/index.php";s:8:"filesize";i:99751;s:6:"header";a:5:{s:4:"text";s:48:"

Class for controlling the TemplaVoila module.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:42:"@author	Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:28:{i:1;a:8:{s:6:"header";s:47:"class tx_templavoila_cm1 extends t3lib_SCbase {";s:5:"class";i:1;s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:48:"

Class for controlling the TemplaVoila module.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:42:"@author	Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:7:"content";a:2:{i:0;s:2163:"
		// Static:
	var $theDisplayMode = '';	// Set to ->MOD_SETTINGS[]
	var $head_markUpTags = array(
			// Block elements:
		'title' => array(),
		'script' => array(),
		'style' => array(),
			// Single elements:

		'link' => array('single'=>1),
		'meta' => array('single'=>1),
	);

		// Internal, dynamic:
	var $markupFile = '';		// Used to store the name of the file to mark up with a given path.
	var $markupObj = '';
	var $elNames = array();
	var $editDataStruct=0;		// Setting whether we are editing a data structure or not.
	var $storageFolders = array();	// Storage folders as key(uid) / value (title) pairs.
	var $storageFolders_pidList=0;	// The storageFolders pids imploded to a comma list including "0"

		// GPvars:
	var $mode;					// Looking for "&mode", which defines if we draw a frameset (default), the module (mod) or display (display)

		// GPvars for MODULE mode
	var $displayFile = '';		// (GPvar "file", shared with DISPLAY mode!) The file to display, if file is referenced directly from filelist module. Takes precedence over displayTable/displayUid
	var $displayTable = '';		// (GPvar "table") The table from which to display element (Data Structure object [tx_templavoila_datastructure], template object [tx_templavoila_tmplobj])
	var $displayUid = '';		// (GPvar "uid") The UID to display (from ->displayTable)
	var $displayPath = '';		// (GPvar "htmlPath") The "HTML-path" to display from the current file

		// GPvars for MODULE mode, specific to mapping a DS:
	var $_preview;
	var $htmlPath;
	var $mapElPath;
	var $doMappingOfPath;
	var $showPathOnly;
	var $mappingToTags;
	var $DS_element;
	var $DS_cmd;
	var $fieldName;

		// GPvars for MODULE mode, specific to creating a DS:
	var $_load_ds_xml_content;
	var $_load_ds_xml_to;
	var $_saveDSandTO_TOuid;
	var $_saveDSandTO_title;
	var $_saveDSandTO_type;
	var $_saveDSandTO_pid;

		// GPvars for DISPLAY mode:
	var $show;					// Boolean; if true no mapping-links are rendered.
	var $preview;				// Boolean; if true, the currentMappingInfo preview data is merged in
	var $limitTags;				// String, list of tags to limit display by
	var $path;					// HTML-path to explode in template.


	";i:1;i:-1;}s:12:"content_size";i:2163;s:13:"content_lines";i:57;s:6:"atLine";i:114;}i:3;a:7:{s:6:"header";s:26:"function menuConfig()    {";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:75:"

Adds items to the ->MOD_MENU array. Used for the function menu selector.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:345:"	    global $LANG;
	    $this->MOD_MENU = Array (
            'displayMode' => array	(
				'explode' => 'Mode: Exploded Visual',
#				'_' => 'Mode: Overlay',
				'source' => 'Mode: HTML Source ',
#				'borders' => 'Mode: Table Borders',
			),
			'showDSxml' => '',
			'selectHeaderContent' => ''
        );
        parent::menuConfig();
    }

	";i:1;i:0;}s:12:"content_size";i:345;s:13:"content_lines";i:14;s:6:"atLine";i:177;}i:5;a:7:{s:6:"header";s:17:"function main()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:148:"

Main function, distributes the load between the module and display modes.
"Display" mode is when the exploded template file is shown in an IFRAME
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:248:"			// Setting GPvars:
		$this->mode = t3lib_div::GPvar('mode');

			// Selecting display or module mode:
		switch((string)$this->mode)	{
			case 'display':
				$this->main_display();
			break;
			default:
				$this->main_mode();
			break;
		}
	}

	";i:1;i:0;}s:12:"content_size";i:248;s:13:"content_lines";i:14;s:6:"atLine";i:198;}i:7;a:7:{s:6:"header";s:25:"function printContent()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:148:"

Prints module content.
Is only used in case of &mode = "mod" since both "display" mode and frameset is outputted + exiting before this is called.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:231:"		$this->content.=$this->doc->middle();
		$this->content.=$this->doc->endPage();
		echo $this->content;
	}









	/*****************************************
	 *
	 * MODULE mode
	 *
	 *****************************************/

	";i:1;i:0;}s:12:"content_size";i:231;s:13:"content_lines";i:19;s:6:"atLine";i:219;}i:9;a:8:{s:6:"header";s:22:"function main_mode()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:11:"sectionText";a:1:{i:0;s:11:"MODULE mode";}s:4:"cDat";a:3:{s:4:"text";s:264:"

Main function of the MODULE. Write the content to $this->content
There are three main modes:
- Based on a file reference, creating/modifying a DS/TO
- Based on a Template Object uid, remapping
- Based on a Data Structure uid, selecting a Template Object to map.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"		global $LANG,$BACK_PATH;

			// Draw the header.
		$this->doc = t3lib_div::makeInstance('noDoc');
		$this->doc->backPath = $BACK_PATH;
		$this->doc->docType = 'xhtml_trans';
		$this->doc->inDocStylesArray[]='
			DIV.typo3-noDoc { width: 98%; margin: 0 0 0 0; }
			DIV.typo3-noDoc H2 { width: 100%; }
			TABLE#c-mapInfo {margin-top: 10px; margin-bottom: 5px; }
			TABLE#c-ma
[...]
plobj') {	// Data source display
			$this->renderTO();
		}

			// Add spacer:
		$this->content.=$this->doc->spacer(10);
	}

	";i:1;i:1;}s:12:"content_size";i:3077;s:13:"content_lines";i:78;s:6:"atLine";i:248;}i:11;a:7:{s:6:"header";s:23:"function renderFile()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:61:"

Renders the display of DS/TO creation directly from a file
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"		if (@is_file($this->displayFile) && t3lib_div::getFileAbsFileName($this->displayFile))		{

				// Converting GPvars into a "cmd" value:
			$cmd = '';
			if (t3lib_div::GPvar('_load_ds_xml'))	{	// Loading DS from XML or TO uid
				$cmd = 'load_ds_xml';
			} elseif (t3lib_div::GPvar('_clear'))	{	// Resetting mapping/DS
				$cmd = 'clear';
			} elseif (t3lib_div::GPvar('_sa
[...]
aStruct,$currentMappingInfo,$menuContent);
				break;
			}
		}

		$this->content.=$this->doc->section('',$content,0,1);
	}

	";i:1;i:1;}s:12:"content_size";i:17694;s:13:"content_lines";i:408;s:6:"atLine";i:332;}i:13;a:7:{s:6:"header";s:22:"function renderDSO()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:49:"

Renders the display of Data Structure Objects.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"		if (intval($this->displayUid)>0)	{
			$row = t3lib_BEfunc::getRecord('tx_templavoila_datastructure',$this->displayUid);
			if (is_array($row))	{

					// Get title and icon:
				$icon = t3lib_iconworks::getIconImage('tx_templavoila_datastructure',$row,$GLOBALS['BACK_PATH'],' align="top" title="UID: '.$this->displayUid.'"');
				$title = t3lib_BEfunc::getRecordTitle('tx_t
[...]
->doc->section('Data Structure Object ERROR','No UID was found pointing to a Data Structure Object record.',0,1,3);
		}
	}

	";i:1;i:1;}s:12:"content_size";i:4799;s:13:"content_lines";i:117;s:6:"atLine";i:746;}i:15;a:7:{s:6:"header";s:21:"function renderTO()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:43:"

Renders the display of Template Objects.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"		if (intval($this->displayUid)>0)	{
			$row = t3lib_BEfunc::getRecord('tx_templavoila_tmplobj',$this->displayUid);

			if (is_array($row))	{

				$tRows=array();
				$tRows[]='
					<tr class="bgColor5">
						<td colspan="2"><strong>Template Object Details:</strong>'.
							t3lib_BEfunc::cshItem('xMOD_tx_templavoila','mapping_to',$this->doc->backPath,'').
							'</td>

[...]
ntent.=$this->doc->section('Template Object ERROR','No UID was found pointing to a Template Object record.',0,1,3);
		}
	}

	";i:1;i:1;}s:12:"content_size";i:6849;s:13:"content_lines";i:158;s:6:"atLine";i:869;}i:17;a:7:{s:6:"header";s:62:"function renderTO_editProcessing(&$dataStruct,$row,$theFile)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:50:"

Process editing of a TO for renderTO() function
";s:5:"param";a:3:{i:0;a:2:{i:0;s:5:"array";i:1;s:112:"Data Structure (without 'meta' section). Passed by reference; The sheets found inside will be resolved if found!";}i:1;a:2:{i:0;s:5:"array";i:1;s:13:"TO record row";}i:2;a:2:{i:0;s:6:"string";i:1;s:29:"Template file path (absolute)";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:186:"Array with two keys (0/1) with a) content and b) currentMappingInfo which is retrieved inside (currentMappingInfo will be different based on whether "head" or "body" content is "mapped")";}s:5:"other";a:1:{i:0;s:15:"@see renderTO()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:11:"renderTO() ";}}}s:7:"content";a:2:{i:0;s:507:"		$msg = array();

			// Converting GPvars into a "cmd" value:
		$cmd = '';
		if (t3lib_div::GPvar('_reload_from'))	{	// Reverting to old values in TO
			$cmd = 'reload_from';
		} elseif (t3lib_div::GPvar('_clear'))	{	// Resetting mapping
			$cmd = 'clear';
		} elseif (t3lib_div::GPvar('_save_data_mapping'))	{	// Saving to Session
			$cmd = 'save_data_mapping';
		} elseif 
[...]
entMappingInfo);
	}





	/*******************************
	 *
	 * Mapper functions
	 *
	 *******************************/

	";i:1;i:1;}s:12:"content_size";i:8206;s:13:"content_lines";i:199;s:6:"atLine";i:1037;}i:19;a:8:{s:6:"header";s:106:"function renderHeaderSelection($displayFile,$currentHeaderMappingInfo,$showBodyTag,$htmlAfterDSTable='')	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:11:"sectionText";a:1:{i:0;s:16:"Mapper functions";}s:4:"cDat";a:3:{s:4:"text";s:75:"

Renders the table with selection of part from the HTML header + bodytag.
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:25:"The abs file name to read";}i:1;a:2:{i:0;s:5:"array";i:1;s:26:"Header mapping information";}i:2;a:2:{i:0;s:7:"boolean";i:1;s:23:"If true, show body tag.";}i:3;a:2:{i:0;s:6:"string";i:1;s:52:"HTML content to show after the Data Structure table.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:11:"HTML table.";}}s:7:"content";a:2:{i:0;s:507:"
			// Get file content
		$this->markupFile = $displayFile;
		$fileContent = t3lib_div::getUrl($this->markupFile);

			// Init mark up object.
		$this->markupObj = t3lib_div::makeInstance('tx_templavoila_htmlmarkup');
		$this->markupObj->init();

			// Get <body> tag:
		$reg='';
		eregi('<body[^>]*>',$fileContent,$reg);
		$html_body = $reg[0];

			// Get <head>...</head> f
[...]
ng_to_headerParts_buttons',$this->doc->backPath,'').
			$htmlAfterDSTable;

			// Return result:
		return $headerParts;
	}

	";i:1;i:1;}s:12:"content_size";i:2105;s:13:"content_lines";i:55;s:6:"atLine";i:1246;}i:21;a:7:{s:6:"header";s:120:"function renderTemplateMapper($displayFile,$path,$dataStruct=array(),$currentMappingInfo=array(),$htmlAfterDSTable='')	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:93:"

Creates the template mapper table + form for either direct file mapping or Template Object
";s:5:"param";a:5:{i:0;a:2:{i:0;s:6:"string";i:1;s:25:"The abs file name to read";}i:1;a:2:{i:0;s:6:"string";i:1;s:143:"The HTML-path to follow. Eg. 'td#content table[1] tr[1] / INNER | img[0]' or so. Normally comes from clicking a tag-image in the display frame.";}i:2;a:2:{i:0;s:5:"array";i:1;s:28:"The data Structure to map to";}i:3;a:2:{i:0;s:5:"array";i:1;s:31:"The current mapping information";}i:4;a:2:{i:0;s:6:"string";i:1;s:52:"HTML content to show after the Data Structure table.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:11:"HTML table.";}}s:7:"content";a:2:{i:0;s:507:"
			// Get file content
		$this->markupFile = $displayFile;
		$fileContent = t3lib_div::getUrl($this->markupFile);

			// Init mark up object.
		$this->markupObj = t3lib_div::makeInstance('tx_templavoila_htmlmarkup');

			// Load splitted content from currentMappingInfo array (used to show us which elements maps to some real content).
		$contentSplittedByMapping = $this->m
[...]
s->makeIframeForVisual($displayFile,$this->displayPath,$limitTags,$this->doMappingOfPath);
			}
		}

		return $content;
	}

	";i:1;i:1;}s:12:"content_size";i:6621;s:13:"content_lines";i:167;s:6:"atLine";i:1312;}i:23;a:7:{s:6:"header";s:214:"function drawDataStructureMap($dataStruct,$mappingMode=0,$currentMappingInfo=array(),$pathLevels=array(),$optDat=array(),$contentSplittedByMapping=array(),$level=0,$tRows=array(),$formPrefix='',$path='',$mapOK=1)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:82:"

Renders the hierarchical display for a Data Structure.
Calls itself recursively
";s:5:"param";a:11:{i:0;a:2:{i:0;s:5:"array";i:1;s:42:"Part of Data Structure (array of elements)";}i:1;a:2:{i:0;s:7:"boolean";i:1;s:129:"If true, the Data Structure table will show links for mapping actions. Otherwise it will just layout the Data Structure visually.";}i:2;a:2:{i:0;s:5:"array";i:1;s:153:"Part of Current mapping information corresponding to the $dataStruct array - used to evaluate the status of mapping for a certain point in the structure.";}i:3;a:2:{i:0;s:5:"array";i:1;s:19:"Array of HTML paths";}i:4;a:2:{i:0;s:5:"array";i:1;s:54:"Options for mapping mode control (INNER, OUTER etc...)";}i:5;a:2:{i:0;s:5:"array";i:1;s:161:"Content from template file splitted by current mapping info - needed to evaluate whether mapping information for a certain level actually worked on live content!";}i:6;a:2:{i:0;s:7:"integer";i:1;s:28:"Recursion level, counting up";}i:7;a:2:{i:0;s:5:"array";i:1;s:98:"Accumulates the table rows containing the structure. This is the array returned from the function.";}i:8;a:2:{i:0;s:6:"string";i:1;s:93:"Form field prefix. For each recursion of this function, two [] parts are added to this prefix";}i:9;a:2:{i:0;s:6:"string";i:1;s:66:"HTML path. For each recursion a section (divided by "|") is added.";}i:10;a:2:{i:0;s:7:"boolean";i:1;s:87:"If true, the "Map" link can be shown, otherwise not. Used internally in the recursions.";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:43:"Table rows as an array of <tr> tags, $tRows";}}s:7:"content";a:2:{i:0;s:507:"
			// Data Structure array must be ... and array of course...
		if (is_array($dataStruct))	{
			foreach($dataStruct as $key => $value)	{
				if (is_array($value))	{	// The value of each entry must be an array.

						// ********************
						// Making the row:
						// ********************
					$rowCells=array();

						// Icon:
					if ($value['type']=='array')	{
		
[...]
 AFTER:
					if ($addEditRows && !$placeBefore)	{
						$tRows[]= $addEditRows;
					}
				}
			}
		}

		return $tRows;
	}

	";i:1;i:1;}s:12:"content_size";i:10295;s:13:"content_lines";i:206;s:6:"atLine";i:1497;}i:25;a:7:{s:6:"header";s:72:"function drawDataStructureMap_editItem($formPrefix,$key,$value,$level)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:80:"

Creates the editing row for a Data Structure element - when DS's are build...
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:19:"Form element prefix";}i:1;a:2:{i:0;s:6:"string";i:1;s:20:"Key for form element";}i:2;a:2:{i:0;s:5:"array";i:1;s:18:"Values for element";}i:3;a:2:{i:0;s:7:"integer";i:1;s:17:"Indentation level";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:111:"Two values, first is addEditRows (string HTML content), second is boolean whether to place row before or after.";}}s:7:"content";a:2:{i:0;s:507:"
			// Init:
		$addEditRows='';
		$placeBefore=0;

			// If editing command is set:
		if ($this->editDataStruct)	{
			if ($this->DS_element == $formPrefix.'['.$key.']')	{	// If the editing-command points to this element:
#debug(t3lib_div::_GET());
#debug(t3lib_div::_POST());

					// Initialize, detecting either "add" or "edit" (default) mode:
				$autokey='';
				if ($thi
[...]
gin-bottom: 0px;').
					'</td>
				</tr>';
			}
		}

			// Return edit row:
		return array($addEditRows,$placeBefore);
	}

	";i:1;i:1;}s:12:"content_size";i:6612;s:13:"content_lines";i:106;s:6:"atLine";i:1713;}i:27;a:7:{s:6:"header";s:88:"function drawDataStructureMap_editItem_editTypeExtra($type, $formFieldName, $curValue)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:6:{s:4:"text";s:68:"

Renders extra form fields for configuration of the Editing Types.
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:19:"Editing Type string";}i:1;a:2:{i:0;s:6:"string";i:1;s:22:"Form field name prefix";}i:2;a:2:{i:0;s:5:"array";i:1;s:46:"Current values for the form field name prefix.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:27:"HTML with extra form fields";}s:5:"other";a:1:{i:0;s:36:"@see drawDataStructureMap_editItem()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:32:"drawDataStructureMap_editItem() ";}}s:6:"access";s:7:"private";}s:7:"content";a:2:{i:0;s:507:"			// If a user function was registered, use that instead of our own handlers:
		if (isset ($GLOBALS['TYPO3_CONF_VARS']['EXTCONF']['templavoila']['cm1']['eTypesExtraFormFields'][$type])) {
			$_params = array (
				'type' => $type,
				'formFieldName' => $formFieldName,
				'curValue' => $curValue,
			);
			$output = t3lib_div::callUserFunction($GLOBALS['TYPO3_CONF_VARS'][
[...]
*******
	 *
	 * Helper-functions for File-based DS/TO creation
	 *
	 ****************************************************/

	";i:1;i:1;}s:12:"content_size";i:1051;s:13:"content_lines";i:38;s:6:"atLine";i:1830;}i:29;a:8:{s:6:"header";s:60:"function substEtypeWithRealStuff(&$elArray,$v_sub=array())	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:11:"sectionText";a:1:{i:0;s:46:"Helper-functions for File-based DS/TO creation";}s:4:"cDat";a:5:{s:4:"text";s:285:"

When mapping HTML files to DS the field types are selected amount some presets - this function converts these presets into the actual settings needed in the DS
Typically called like: ->substEtypeWithRealStuff($storeDataStruct['ROOT']['el'],$contentSplittedByMapping['sub']['ROOT']);
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:46:"$elArray: Data Structure, passed by reference!";}i:1;a:2:{i:0;s:5:"array";i:1;s:58:"$v_sub: Actual template content splitted by Data Structure";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:48:"Note: The result is directly written in $elArray";}s:5:"other";a:1:{i:0;s:17:"@see renderFile()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:13:"renderFile() ";}}}s:7:"content";a:2:{i:0;s:507:"
			// Traverse array
		foreach($elArray as $key => $value)	{

			unset($elArray[$key]['tx_templavoila']['proc']);

			if ($elArray[$key]['type']=='array')	{	// If array, then unset:
				unset($elArray[$key]['tx_templavoila']['sample_data']);

			} else {	// Only non-arrays can have configuration (that is elements and attributes)

					// Getting some information about the
[...]
rray[$key]['el']))	{
				$this->substEtypeWithRealStuff($elArray[$key]['el'],$v_sub['sub'][$key]);
			}
		}	// End loop
	}

	";i:1;i:1;}s:12:"content_size";i:7606;s:13:"content_lines";i:231;s:6:"atLine";i:1878;}i:31;a:7:{s:6:"header";s:56:"function substEtypeWithRealStuff_contentInfo($content)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:144:"

Analyzes the input content for various stuff which can be used to generate the DS.
Basically this tries to intelligently guess some settings.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:19:"HTML Content string";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:13:"Configuration";}s:5:"other";a:1:{i:0;s:30:"@see substEtypeWithRealStuff()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:26:"substEtypeWithRealStuff() ";}}}s:7:"content";a:2:{i:0;s:507:"		if ($content)	{
			if (substr($content,0,4)=='<img')	{
				$attrib = t3lib_div::get_tag_attributes($content);
				if ((!$attrib['width'] || !$attrib['height']) && $attrib['src'])	{
					$pathWithNoDots = t3lib_div::resolveBackPath($attrib['src']);
					$filePath = t3lib_div::getFileAbsFileName($pathWithNoDots);
					if ($filePath && @is_file($filePath))	{
						$imgInfo 
[...]
}















	/*******************************
	 *
	 * Various helper functions
	 *
	 *******************************/

	";i:1;i:1;}s:12:"content_size";i:706;s:13:"content_lines";i:38;s:6:"atLine";i:2118;}i:33;a:8:{s:6:"header";s:52:"function getDataStructFromDSO($datString,$file='')	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:11:"sectionText";a:1:{i:0;s:24:"Various helper functions";}s:4:"cDat";a:3:{s:4:"text";s:45:"

Returns Data Structure from the $datString
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:61:"XML content which is parsed into an array, which is returned.";}i:1;a:2:{i:0;s:6:"string";i:1;s:88:"Absolute filename from which to read the XML data. Will override any input in $datString";}}s:6:"return";a:2:{i:0;s:5:"mixed";i:1;s:129:"The variable $dataStruct. Should be array. If string, then no structures was found and the function returns the XML parser error.";}}s:7:"content";a:2:{i:0;s:173:"		if ($file)	{
			$dataStruct = t3lib_div::xml2array(t3lib_div::getUrl($file));
		} else {
			$dataStruct = t3lib_div::xml2array($datString);
		}
		return $dataStruct;
	}

	";i:1;i:0;}s:12:"content_size";i:173;s:13:"content_lines";i:8;s:6:"atLine";i:2164;}i:35;a:7:{s:6:"header";s:45:"function linkForDisplayOfPath($title,$path)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:85:"

Creating a link to the display frame for display of the "HTML-path" given as $path
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:16:"The text to link";}i:1;a:2:{i:0;s:6:"string";i:1;s:29:"The path string ("HTML-path")";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:41:"HTML link, pointing to the display frame.";}}s:7:"content";a:2:{i:0;s:288:"		$theArray=array(
			'file' => $this->markupFile,
			'path' => $path,
			'mode' => 'display'
		);
		$p = t3lib_div::implodeArrayForUrl('',$theArray);

		$content.='<strong><a href="'.htmlspecialchars('index.php?'.$p).'" target="display">'.$title.'</a></strong>';
		return $content;
	}

	";i:1;i:0;}s:12:"content_size";i:288;s:13:"content_lines";i:11;s:6:"atLine";i:2180;}i:37;a:7:{s:6:"header";s:41:"function linkThisScript($array=array())	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:153:"

Creates a link to this script, maintaining the values of the displayFile, displayTable, displayUid variables.
Primarily used by ->drawDataStructureMap
";s:5:"param";a:1:{i:0;a:2:{i:0;s:5:"array";i:1;s:22:"Overriding parameters.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:34:"URL, already htmlspecialchars()'ed";}s:5:"other";a:1:{i:0;s:27:"@see drawDataStructureMap()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:23:"drawDataStructureMap() ";}}}s:7:"content";a:2:{i:0;s:250:"		$theArray=array(
			'file' => $this->displayFile,
			'table' => $this->displayTable,
			'uid' => $this->displayUid,
		);
		$p = t3lib_div::implodeArrayForUrl('',array_merge($theArray,$array),'',1);

		return htmlspecialchars('index.php?'.$p);
	}

	";i:1;i:0;}s:12:"content_size";i:250;s:13:"content_lines";i:10;s:6:"atLine";i:2200;}i:39;a:7:{s:6:"header";s:75:"function makeIframeForVisual($file,$path,$limitTags,$showOnly,$preview=0)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:75:"

Creates the HTML code for the IFRAME in which the display mode is shown:
";s:5:"param";a:5:{i:0;a:2:{i:0;s:6:"string";i:1;s:38:"File name to display in exploded mode.";}i:1;a:2:{i:0;s:6:"string";i:1;s:9:"HTML-page";}i:2;a:2:{i:0;s:6:"string";i:1;s:35:"Tags which is the only ones to show";}i:3;a:2:{i:0;s:7:"boolean";i:1;s:59:"If set, the template is only shown, mapping links disabled.";}i:4;a:2:{i:0;s:7:"boolean";i:1;s:16:"Preview enabled.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:25:"HTML code for the IFRAME.";}s:5:"other";a:1:{i:0;s:19:"@see main_display()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:15:"main_display() ";}}}s:7:"content";a:2:{i:0;s:348:"		$url = 'index.php?mode=display'.
				'&file='.rawurlencode($file).
				'&path='.rawurlencode($path).
				'&preview='.($preview?1:0).
				($showOnly?'&show=1':'&limitTags='.rawurlencode($limitTags));
		return '<iframe width="100%" height="500" src="'.htmlspecialchars($url).'#_MARKED_UP_ELEMENT" style="border: 1xpx solid black;"></iframe>';
	}

	";i:1;i:0;}s:12:"content_size";i:348;s:13:"content_lines";i:8;s:6:"atLine";i:2222;}i:41;a:7:{s:6:"header";s:62:"function explodeMappingToTagsStr($mappingToTags,$unsetAll=0)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:47:"

Converts a list of mapping rules to an array
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:23:"Mapping rules in a list";}i:1;a:2:{i:0;s:7:"boolean";i:1;s:50:"If set, then the ALL rule (key "*") will be unset.";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:42:"Mapping rules in a multidimensional array.";}}s:7:"content";a:2:{i:0;s:305:"		$elements = t3lib_div::trimExplode(',',strtolower($mappingToTags));
		$output=array();
		foreach($elements as $v)	{
			$subparts = t3lib_div::trimExplode(':',$v);
			$output[$subparts[0]][$subparts[1]][($subparts[2]?$subparts[2]:'*')]=1;
		}
		if ($unsetAll)	unset($output['*']);
		return $output;
	}

	";i:1;i:0;}s:12:"content_size";i:305;s:13:"content_lines";i:10;s:6:"atLine";i:2238;}i:43;a:7:{s:6:"header";s:44:"function unsetArrayPath(&$dataStruct,$ref)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:68:"

General purpose unsetting of elements in a multidimensional array
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:58:"Array from which to remove elements (passed by reference!)";}i:1;a:2:{i:0;s:5:"array";i:1;s:94:"An array where the values in the specified order points to the position in the array to unset.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:182:"		$key = array_shift($ref);

		if (!count($ref))	{
			unset($dataStruct[$key]);
		} elseif (is_array($dataStruct[$key]))	{
			$this->unsetArrayPath($dataStruct[$key],$ref);
		}
	}

	";i:1;i:0;}s:12:"content_size";i:182;s:13:"content_lines";i:9;s:6:"atLine";i:2256;}i:45;a:7:{s:6:"header";s:76:"function cleanUpMappingInfoAccordingToDS(&$currentMappingInfo,$dataStruct)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:161:"

Function to clean up "old" stuff in the currentMappingInfo array. Basically it will remove EVERYTHING which is not known according to the input Data Structure
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:42:"Current Mapping info (passed by reference)";}i:1;a:2:{i:0;s:5:"array";i:1;s:14:"Data Structure";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:356:"		if (is_array($currentMappingInfo))	{
			foreach($currentMappingInfo as $key => $value)	{
				if (!isset($dataStruct[$key]))	{
					unset($currentMappingInfo[$key]);
				} else {
					if (is_array($dataStruct[$key]['el']))	{
						$this->cleanUpMappingInfoAccordingToDS($currentMappingInfo[$key]['el'],$dataStruct[$key]['el']);
					}
				}
			}
		}
	}

	";i:1;i:0;}s:12:"content_size";i:356;s:13:"content_lines";i:13;s:6:"atLine";i:2273;}i:47;a:7:{s:6:"header";s:36:"function findingStorageFolderIds()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:101:"

Generates $this->storageFolders with available sysFolders linked to as storageFolders for the user
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:43:"Modification in $this->storageFolders array";}}s:7:"content";a:2:{i:0;s:507:"
			// Init:
		$readPerms = $GLOBALS['BE_USER']->getPagePermsClause(1);
		$this->storageFolders=array();

			// Looking up all references to a storage folder:
		$query = 'SELECT uid,storage_pid FROM pages WHERE storage_pid>0'.t3lib_BEfunc::deleteClause('pages');
		$res = mysql(TYPO3_db,$query);
		while($row = mysql_fetch_assoc($res))	{
			if ($GLOBALS['BE_USER']->isInWebMo
[...]
}







	/*****************************************
	 *
	 * DISPLAY mode
	 *
	 *****************************************/

	";i:1;i:1;}s:12:"content_size";i:922;s:13:"content_lines";i:35;s:6:"atLine";i:2292;}i:49;a:8:{s:6:"header";s:25:"function main_display()	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:11:"sectionText";a:1:{i:0;s:12:"DISPLAY mode";}s:4:"cDat";a:5:{s:4:"text";s:61:"

Outputs the display of a marked-up HTML file in the IFRAME
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:19:"Exits before return";}s:5:"other";a:1:{i:0;s:26:"@see makeIframeForVisual()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:22:"makeIframeForVisual() ";}}}s:7:"content";a:2:{i:0;s:507:"
			// Setting GPvars:
		$this->displayFile = t3lib_div::GPvar('file');
		$this->show = t3lib_div::GPvar('show');
		$this->preview = t3lib_div::GPvar('preview');
		$this->limitTags = t3lib_div::GPvar('limitTags');
		$this->path = t3lib_div::GPvar('path');

			// Checking if the displayFile parameter is set:
		if (@is_file($this->displayFile) && t3lib_div::getFileAbsFileNam
[...]
 {
			$this->displayFrameError('No file to display');
		}

			// Exit since a full page has been outputted now.
		exit;
	}

	";i:1;i:1;}s:12:"content_size";i:1310;s:13:"content_lines";i:34;s:6:"atLine";i:2334;}i:51;a:7:{s:6:"header";s:78:"function displayFileContentWithMarkup($content,$path,$relPathFix,$limitTags)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:75:"

This will mark up the part of the HTML file which is pointed to by $path
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:28:"The file content as a string";}i:1;a:2:{i:0;s:6:"string";i:1;s:27:"The "HTML-path" to split by";}i:2;a:2:{i:0;s:6:"string";i:1;s:45:"The rel-path string to fix images/links with.";}i:3;a:2:{i:0;s:6:"string";i:1;s:20:"List of tags to show";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:8:"Exits...";}s:5:"other";a:1:{i:0;s:19:"@see main_display()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:15:"main_display() ";}}}s:7:"content";a:2:{i:0;s:507:"		$markupObj = t3lib_div::makeInstance('tx_templavoila_htmlmarkup');
		$markupObj->gnyfImgAdd = $this->show ? '' : 'onclick="return parent.updPath(\'###PATH###\');"';
		$markupObj->pathPrefix = $path?$path.'|':'';
		$markupObj->onlyElements = $limitTags;

		$cParts = $markupObj->splitByPath($content,$path);
		if (is_array($cParts))	{
			$cParts[1] = $markupObj->markupHTMLc
[...]
_UP_ELEMENT"></a>'.$cParts[1];
			}
			return implode('',$cParts);
		} else {
			$this->displayFrameError($cParts);
		}
	}

	";i:1;i:1;}s:12:"content_size";i:959;s:13:"content_lines";i:25;s:6:"atLine";i:2379;}i:53;a:4:{s:6:"header";s:62:"function displayFileContentWithPreview($content,$relPathFix)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:5:{s:4:"text";s:101:"

This will add preview data to the HTML file used as a template according to the currentMappingInfo
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:28:"The file content as a string";}i:1;a:2:{i:0;s:6:"string";i:1;s:45:"The rel-path string to fix images/links with.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:8:"Exits...";}s:5:"other";a:1:{i:0;s:19:"@see main_display()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:15:"main_display() ";}}}s:6:"atLine";i:2413;}i:55;a:7:{s:6:"header";s:36:"function displayFrameError($error)	{";s:11:"parentClass";s:18:"tx_templavoila_cm1";s:4:"cDat";a:3:{s:4:"text";s:51:"

Outputs a simple HTML page with an error message
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:37:"Error message for output in <h2> tags";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:23:"Echos out an HTML page.";}}s:7:"content";a:2:{i:0;s:527:"			echo '
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">

<html>
<head>
	<title>Untitled</title>
</head>

<body bgcolor="#eeeeee">
<h2>ERROR: '.$error.'</h2>
</body>
</html>
			';
	}
}

if (defined('TYPO3_MODE') && $TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/cm1/index.php'])	{
	include_once($TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/cm1/index.php']);
}


// Make instance:
$SOBE = t3lib_div::makeInstance('tx_templavoila_cm1');
$SOBE->init();
$SOBE->main();
$SOBE->printContent();
?>
";i:1;i:0;}s:12:"content_size";i:527;s:13:"content_lines";i:27;s:6:"atLine";i:2449;}}}s:14:"MD5_19aaeae789";a:4:{s:8:"filename";s:14:"mod1/index.php";s:8:"filesize";i:61247;s:6:"header";a:5:{s:4:"text";s:49:"

Module 'Page' for the 'templavoila' extension.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:4:{i:0;s:41:"@author		Robert Lemke <rl@robertlemke.de>";i:1;s:44:"@coauthor	Kasper Skaarhoj <kasper@typo3.com>";i:2;s:15:"@package		TYPO3";i:3;s:26:"@subpackage	tx_templavoila";}s:11:"other_index";a:4:{s:7:"@author";a:1:{i:0;s:32:"Robert Lemke <rl@robertlemke.de>";}s:9:"@coauthor";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:33:{i:1;a:8:{s:6:"header";s:51:"class tx_templavoila_module1 extends t3lib_SCbase {";s:5:"class";i:1;s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:49:"

Module 'Page' for the 'templavoila' extension.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:4:{i:0;s:41:"@author		Robert Lemke <rl@robertlemke.de>";i:1;s:44:"@coauthor	Kasper Skaarhoj <kasper@typo3.com>";i:2;s:15:"@package		TYPO3";i:3;s:26:"@subpackage	tx_templavoila";}s:11:"other_index";a:4:{s:7:"@author";a:1:{i:0;s:32:"Robert Lemke <rl@robertlemke.de>";}s:9:"@coauthor";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:7:"content";a:2:{i:0;s:787:"	var $rulesObj;									// Holds an instance of the tx_templavoila_rule
	var $modTSconfig;
	var $extKey = 'templavoila';					// Extension key of this module

	var $global_tt_content_elementRegister=array();
	var $elementBlacklist=array();					// Used in renderFrameWork (list of CEs causing errors)

	var $altRoot = array();							// Keys: "table", "uid", "field_flex" - thats all to define another "rootTable" than "pages" (using default field "tx_templavoila_flex" for flex form content)
	var $selectedLanguage = 'DEF';

	var $currentDSXMLArr;							// Contains the data structure XML structure as an array of the currently selected DS record when editing a page
	var $currentPageRecord;							// Contains the page record (from table 'pages') of the current page when editing a page

	";i:1;i:-1;}s:12:"content_size";i:787;s:13:"content_lines";i:13;s:6:"atLine";i:112;}i:3;a:7:{s:6:"header";s:20:"function init()    {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:40:"

Initialisation of this backend module
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:249:"		parent::init();
		$this->rulesObj = tx_templavoila_rules::getInstance();
		$this->MOD_SETTINGS = t3lib_BEfunc::getModuleData($this->MOD_MENU, t3lib_div::GPvar('SET'), $this->MCONF['name']);

		$this->altRoot = t3lib_div::GPvar('altRoot', 1);
	}

	";i:1;i:0;}s:12:"content_size";i:249;s:13:"content_lines";i:7;s:6:"atLine";i:131;}i:5;a:7:{s:6:"header";s:23:"function menuConfig()	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:72:"

Preparing menu content and initializing clipboard and module TSconfig
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"		global $LANG;

		$this->MOD_MENU = array(
			'view' => array(
				0 => $LANG->getLL('view_basic'),
			),
			'showHeaderFields' => '',
			'sheetData' => '',
			'clip_parentPos' => '',
			'clip' => '',
		);

			// page/be_user TSconfig settings and blinding of menu-items
		$this->modTSconfig = t3lib_BEfunc::getModTSconfig($this->id,'mod.'.$this->MCONF['name']);
		$this->MO
[...]
GS
		$this->MOD_SETTINGS = t3lib_BEfunc::getModuleData($this->MOD_MENU, t3lib_div::GPvar('SET'), $this->MCONF['name']);
	}

	";i:1;i:1;}s:12:"content_size";i:642;s:13:"content_lines";i:20;s:6:"atLine";i:144;}i:7;a:7:{s:6:"header";s:20:"function main()    {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:31:"

Main function of the module.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:507:"		global $BE_USER,$LANG,$BACK_PATH;

			// Access check! The page will show only if there is a valid page and if this page may be viewed by the user
		if (is_array($this->altRoot))	{
			$access = true;
		} else {
			$pageInfoArr = t3lib_BEfunc::readPageAccess($this->id, $this->perms_clause);
			$access = (intval($pageInfoArr['uid'] > 0));
		}

		if ($access)    {

				// C
[...]
	/*******************************************
	 *
	 * Command functions
	 *
	 *******************************************/

	";i:1;i:1;}s:12:"content_size";i:3157;s:13:"content_lines";i:95;s:6:"atLine";i:170;}i:9;a:8:{s:6:"header";s:59:"function cmd_createNewRecord ($parentRecord, $defVals='') {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:11:"sectionText";a:1:{i:0;s:17:"Command functions";}s:4:"cDat";a:5:{s:4:"text";s:50:"

Initiates processing for creating a new record.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:79:"$params: Array containing parameters for creating the new record (see function)";}i:1;a:2:{i:0;s:5:"array";i:1;s:95:"$defVals: Array containing default values for the new record, e.g. [tt_content][CType] = 'text'";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}s:5:"other";a:1:{i:0;s:21:"@see		insertRecord ()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:15:"insertRecord ()";}}}s:7:"content";a:2:{i:0;s:588:"			// Historically "defVals" has been used for submitting the row data. We still use it and use it for our new row:
		$defVals = (string)$defVals == '' ? t3lib_div::GPvar('defVals') : $defVals;
		$row = $defVals['tt_content'];

			// Create new record and open it for editing
		$newUid = $this->insertRecord($parentRecord, $row);
		$location = $GLOBALS['BACK_PATH'].'alt_doc.php?edit[tt_content]['.$newUid.']=edit&returnUrl='.rawurlencode(t3lib_extMgm::extRelPath('templavoila').'mod1/index.php?'.$this->linkParams());
		header('Location: '.t3lib_div::locationHeaderUrl($location));
	}

	";i:1;i:0;}s:12:"content_size";i:588;s:13:"content_lines";i:10;s:6:"atLine";i:274;}i:11;a:7:{s:6:"header";s:43:"function cmd_unlinkRecord ($unlinkRecord) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:47:"

Initiates processing for unlinking a record.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:42:"$unlinkRecord: The element to be unlinked.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}s:5:"other";a:1:{i:0;s:20:"@see		pasteRecord ()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:14:"pasteRecord ()";}}}s:7:"content";a:2:{i:0;s:143:"		$this->pasteRecord('unlink', $unlinkRecord, '');
		header('Location: '.t3lib_div::locationHeaderUrl('index.php?'.$this->linkParams()));
	}

	";i:1;i:0;}s:12:"content_size";i:143;s:13:"content_lines";i:4;s:6:"atLine";i:292;}i:13;a:7:{s:6:"header";s:43:"function cmd_deleteRecord ($deleteRecord) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:60:"

Initiates processing for unlinking AND DELETING a record.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:42:"$unlinkRecord: The element to be unlinked.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}s:5:"other";a:1:{i:0;s:20:"@see		pasteRecord ()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:14:"pasteRecord ()";}}}s:7:"content";a:2:{i:0;s:143:"		$this->pasteRecord('delete', $deleteRecord, '');
		header('Location: '.t3lib_div::locationHeaderUrl('index.php?'.$this->linkParams()));
	}

	";i:1;i:0;}s:12:"content_size";i:143;s:13:"content_lines";i:4;s:6:"atLine";i:304;}i:15;a:7:{s:6:"header";s:49:"function cmd_makeLocalRecord ($makeLocalRecord) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:60:"

Initiates processing for making a local copy of a record.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:56:"$unlinkRecord: The element to be copied to current page.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}s:5:"other";a:1:{i:0;s:20:"@see		pasteRecord ()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:14:"pasteRecord ()";}}}s:7:"content";a:2:{i:0;s:149:"		$this->pasteRecord('localcopy', $makeLocalRecord, '');
		header('Location: '.t3lib_div::locationHeaderUrl('index.php?'.$this->linkParams()));
	}

	";i:1;i:0;}s:12:"content_size";i:149;s:13:"content_lines";i:4;s:6:"atLine";i:316;}i:17;a:7:{s:6:"header";s:41:"function cmd_pasteRecord ($pasteRecord) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:45:"

Initiates processing for pasting a record.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"string";i:1;s:39:"$pasteRecord: The element to be pasted.";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}s:5:"other";a:1:{i:0;s:20:"@see		pasteRecord ()";}s:11:"other_index";a:1:{s:4:"@see";a:1:{i:0;s:14:"pasteRecord ()";}}}s:7:"content";a:2:{i:0;s:321:"		$this->pasteRecord($pasteRecord, t3lib_div::GPvar('target'), t3lib_div::GPvar('destination'));
		header('Location: '.t3lib_div::locationHeaderUrl('index.php?'.$this->linkParams()));
	}





	/********************************************
	 *
	 * Rendering functions
	 *
	 ********************************************/

	";i:1;i:0;}s:12:"content_size";i:321;s:13:"content_lines";i:14;s:6:"atLine";i:328;}i:19;a:8:{s:6:"header";s:36:"function renderEditPageScreen()    {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:11:"sectionText";a:1:{i:0;s:19:"Rendering functions";}s:4:"cDat";a:3:{s:4:"text";s:81:"

Displays the default view of a page, showing the nested structure of elements.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:19:"The modules content";}}s:7:"content";a:2:{i:0;s:507:"		global $LANG, $BE_USER, $TYPO3_CONF_VARS;

			// Reset internal variable:
		$this->global_tt_content_elementRegister=array();

			// Get data structure array for the page/content elements.
			// Returns a BIG array reflecting the "treestructure" of the pages content elements.
		if (is_array($this->altRoot))	{
			$dsArr = $this->getDStreeForPage($this->altRoot['table'], $
[...]
ib_BEfunc::cshItem('xMOD_tx_templavoila', 'pagemodule_notUsed', $this->doc->backPath,'|<br/>');
		}

		return $content;
	}

	";i:1;i:1;}s:12:"content_size";i:2379;s:13:"content_lines";i:50;s:6:"atLine";i:348;}i:21;a:7:{s:6:"header";s:48:"function renderCreatePageScreen ($positionPid) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:43:"

Creates the screen for "new page wizard"
";s:5:"param";a:1:{i:0;a:2:{i:0;s:7:"integer";i:1;s:248:"$positionPid: Can be positive and negative depending of where the new page is going: Negative always points to a position AFTER the page having the abs. value of the positionId. Positive numbers means to create as the first subpage to another page.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:30:"Content for the screen output.";}s:5:"other";a:1:{i:0;s:45:"@todo				Check required field(s), support t3d";}s:11:"other_index";a:1:{s:5:"@todo";a:1:{i:0;s:36:"Check required field(s), support t3d";}}}s:7:"content";a:2:{i:0;s:507:"		global $LANG, $BE_USER, $TYPO3_CONF_VARS;

			// The user already submitted the create page form:
		if (t3lib_div::GPvar ('doCreate')) {
				// Check if the HTTP_REFERER is valid
			$refInfo=parse_url(t3lib_div::getIndpEnv('HTTP_REFERER'));
			$httpHost = t3lib_div::getIndpEnv('TYPO3_HOST_ONLY');
			if ($httpHost==$refInfo['host'] || t3lib_div::GPvar('vC')==$BE_USER->ver
[...]
id" value="'.$positionPid.'" />';
		$content .= '<input type="hidden" name="cmd" value="crPage" />';
		return $content;
	}

	";i:1;i:1;}s:12:"content_size";i:3167;s:13:"content_lines";i:69;s:6:"atLine";i:406;}i:23;a:7:{s:6:"header";s:73:"function renderTemplateSelector ($positionPid, $templateType='tmplobj') {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:33:"

Renders the template selector.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:7:"integer";i:1;s:247:"Position id. Can be positive and negative depending of where the new page is going: Negative always points to a position AFTER the page having the abs. value of the positionId. Positive numbers means to create as the first subpage to another page.";}i:1;a:2:{i:0;s:6:"string";i:1;s:89:"$templateType: The template type, currently only 'tmplobj' is supported, 't3d' is planned";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:57:"HTML output containing a table with the template selector";}}s:7:"content";a:2:{i:0;s:507:"		global $LANG;
		$storageFolderPID = $this->getStorageFolderPid($positionPid);

		switch ($templateType) {
			case 'tmplobj':
						// Create the "Default template" entry
				$previewIconFilename = $GLOBALS['BACK_PATH'].'../'.t3lib_extMgm::siteRelPath($this->extKey).'res1/default_previewicon.gif';
				$previewIcon = '<input type="image" class="c-inputButton" name="data[tx
[...]
********************************
	 *
	 * Framework rendering functions
	 *
	 ********************************************/

	";i:1;i:1;}s:12:"content_size";i:2698;s:13:"content_lines";i:54;s:6:"atLine";i:483;}i:25;a:8:{s:6:"header";s:92:"function renderFrameWork($dsInfo, $parentPos='', $clipboardElInPath=0, $referenceInPath=0) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:11:"sectionText";a:1:{i:0;s:29:"Framework rendering functions";}s:4:"cDat";a:3:{s:4:"text";s:58:"

Renders the display framework.
Calls itself recursively
";s:5:"param";a:4:{i:0;a:2:{i:0;s:5:"array";i:1;s:50:"$dsInfo: DataStructure info array (the whole tree)";}i:1;a:2:{i:0;s:6:"string";i:1;s:94:"$parentPos: Pointer to parent element: table, id, sheet, fieldname, counter (position in list)";}i:2;a:2:{i:0;s:7:"boolean";i:1;s:300:"$clipboardElInPath: Tells whether any element registered on the clipboard is found in the current "path" of the recursion. If true, it normally means that no paste-in symbols are shown since elements are not allowed to be pasted/referenced to a position within themselves (would result in recursion).";}i:3;a:2:{i:0;s:7:"boolean";i:1;s:107:"$referenceInPath: Is set to the number of references there has been in previous recursions of this function";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:4:"HTML";}}s:7:"content";a:2:{i:0;s:507:"		global $LANG;
			// Setting the sheet ID and render sheet menu:
		$sheet = isset($dsInfo['sub'][$this->MOD_SETTINGS['sheetData']]) ? $this->MOD_SETTINGS['sheetData'] : 'sDEF';

			// The $isLocal flag is used to denote whether an element belongs to the current page or not. If NOT the $isLocal flag means (for instance) that the title bar will be colored differently to sho
[...]
LineWithin ? '<br />'.$errorLineWithin : '').'</td></tr>
		</table>
		'.$errorLineAfter.'
		';

		return $finalContent;
	}

	";i:1;i:1;}s:12:"content_size";i:11471;s:13:"content_lines";i:141;s:6:"atLine";i:548;}i:27;a:7:{s:6:"header";s:51:"function renderSheetMenu ($dsInfo, $currentSheet) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:217:"

Render sheet menu:
Design-wise this will change most likely. And we also need to do a proper registration of the sheets since it only
works for the page at this point - not content elements deeper in the structure.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:55:"$dsInfo: Datastructure containing the sheet information";}i:1;a:2:{i:0;s:6:"string";i:1;s:43:"$currentSheet: The currently selected sheet";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:4:"HTML";}}s:7:"content";a:2:{i:0;s:507:"		$sheetMenu='';
		if (is_array($dsInfo['sub']))	{
			if (count($dsInfo['sub'])>1 || !isset($dsInfo['sub']['sDEF']))	{

				$count = count($dsInfo['sub']);
				$widthLeft = 1;
				$addToAct = 5;

				$widthRight = max (1,floor(30-pow($count,1.72)));
				$widthTabs = 100 - $widthRight - $widthLeft;
				$widthNo = floor(($widthTabs - $addToAct)/$count);
				$addToAct = max (
[...]
rder="0" style="padding-left: 3px; padding-right: 3px;"><tr>'.$sheetMenu.'</tr></table>';
			}
		}
		return $sheetMenu;
	}

	";i:1;i:1;}s:12:"content_size";i:1344;s:13:"content_lines";i:40;s:6:"atLine";i:699;}i:29;a:7:{s:6:"header";s:39:"function renderHeaderFields ($pageId) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:300:"

Render header fields: It's possible to define a list of fields (currently only from the pages table) which should appear
as a header above the content zones while editing the content of a page. This function renders those fields.
The fields to be displayed are defined in the page's datastructure.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:7:"integer";i:1;s:61:"$pageId: The page's ID for which to display the header fields";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:4:"HTML";}}s:7:"content";a:2:{i:0;s:507:"		global $LANG;
		$content = '';

		$state = intval($this->MOD_SETTINGS['showHeaderFields']);
		$label = htmlspecialchars($LANG->getLL ($state ? 'hideheaderinformation' : 'showheaderinformation'));
		$href = t3lib_div::linkThisScript (array('SET'=>array('showHeaderFields'=>$state ? 0 : 1)));

		$showHideButton = '<a href="'.$href.'"><img'.t3lib_iconWorks::skinImg($this->do
[...]
ue.'</em></td></tr>';
							}
						}
					}
					$content .= '</tr></table><br />';
				}
			}
		}
		return $content;
	}

	";i:1;i:1;}s:12:"content_size";i:2990;s:13:"content_lines";i:50;s:6:"atLine";i:748;}i:31;a:7:{s:6:"header";s:26:"function renderNonUsed()	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:119:"

Displays a list of local content elements on the page which were NOT used in the hierarchical structure of the page.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:19:"Display output HTML";}s:5:"other";a:1:{i:0;s:156:"@todo	Clean up this list so it becomes full-features for the elements shown (having all the editing, copy, cut, blablabla features that other elements have)";}s:11:"other_index";a:1:{s:5:"@todo";a:1:{i:0;s:150:"Clean up this list so it becomes full-features for the elements shown (having all the editing, copy, cut, blablabla features that other elements have)";}}}s:7:"content";a:2:{i:0;s:507:"		global $LANG;

		$usedUids = array_keys($this->global_tt_content_elementRegister);
		$usedUids[]=0;

		$query = 'SELECT uid,header FROM tt_content WHERE pid='.intval($this->id).' AND uid NOT IN ('.implode(',',$usedUids).')'.t3lib_BEfunc::deleteClause('tt_content').' ORDER BY uid';
		$res = mysql(TYPO3_db,$query);
		$tRows='';
		while($row=mysql_fetch_assoc($res))	{
			$c
[...]
 = is_array ($tRows) ? ('Not used records:<br /><table border="1">'.implode('',$tRows).'</table>') : '';
		return $out;
	}

	";i:1;i:1;}s:12:"content_size";i:977;s:13:"content_lines";i:17;s:6:"atLine";i:805;}i:33;a:7:{s:6:"header";s:37:"function linkEdit($str,$table,$uid)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:35:"

Returns an HTML link for editing
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:26:"$str: The label (or image)";}i:1;a:2:{i:0;s:6:"string";i:1;s:35:"$table: The table, fx. 'tt_content'";}i:2;a:2:{i:0;s:7:"integer";i:1;s:41:"$uid: The uid of the element to be edited";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:57:"HTML anchor tag containing the label and the correct link";}}s:7:"content";a:2:{i:0;s:211:"		$onClick = t3lib_BEfunc::editOnClick('&edit['.$table.']['.$uid.']=edit',$this->doc->backPath);
		return '<a style="text-decoration: none;" href="#" onclick="'.htmlspecialchars($onClick).'">'.$str.'</a>';
	}

	";i:1;i:0;}s:12:"content_size";i:211;s:13:"content_lines";i:4;s:6:"atLine";i:831;}i:35;a:7:{s:6:"header";s:38:"function linkNew($str,$parentRecord)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:49:"

Returns an HTML link for creating a new record
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:26:"$str: The label (or image)";}i:1;a:2:{i:0;s:6:"string";i:1;s:101:"$parentRecord: The parameters for creating the new record. Example: pages:78:sDEF:field_contentarea:0";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:57:"HTML anchor tag containing the label and the correct link";}}s:7:"content";a:2:{i:0;s:152:"		return '<a href="'.htmlspecialchars('db_new_content_el.php?'.$this->linkParams().'&parentRecord='.rawurlencode($parentRecord)).'">'.$str.'</a>';
	}

	";i:1;i:0;}s:12:"content_size";i:152;s:13:"content_lines";i:3;s:6:"atLine";i:843;}i:37;a:7:{s:6:"header";s:60:"function linkUnlink($str,$unlinkRecord, $realDelete=FALSE)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:160:"

Returns an HTML link for unlinking a content element. Unlinking means that the record still exists but
is not connected to any other content element or page.
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:15:"$str: The label";}i:1;a:2:{i:0;s:6:"string";i:1;s:98:"$unlinkRecord: The parameters for unlinking the record. Example: pages:78:sDEF:field_contentarea:0";}i:2;a:2:{i:0;s:6:"[type]";i:1;s:16:"$realDelete: ...";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:56:"HTML anchor tag containing the label and the unlink-link";}}s:7:"content";a:2:{i:0;s:394:"		global $LANG;

		if ($realDelete)	{
			return '<a href="index.php?'.$this->linkParams().'&deleteRecord='.rawurlencode($unlinkRecord).'" onclick="'.htmlspecialchars('return confirm('.$LANG->JScharCode($LANG->getLL('deleteRecordMsg')).');').'">'.$str.'</a>';
		} else {
			return '<a href="index.php?'.$this->linkParams().'&unlinkRecord='.rawurlencode($unlinkRecord).'">'.$str.'</a>';
		}
	}

	";i:1;i:0;}s:12:"content_size";i:394;s:13:"content_lines";i:9;s:6:"atLine";i:856;}i:39;a:7:{s:6:"header";s:47:"function linkMakeLocal($str,$makeLocalRecord)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:94:"

Returns an HTML link for making a reference content element local to the page (copying it).
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:15:"$str: The label";}i:1;a:2:{i:0;s:6:"string";i:1;s:98:"$unlinkRecord: The parameters for unlinking the record. Example: pages:78:sDEF:field_contentarea:0";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:56:"HTML anchor tag containing the label and the unlink-link";}}s:7:"content";a:2:{i:0;s:245:"		global $LANG;

		return '<a href="index.php?'.$this->linkParams().'&makeLocalRecord='.rawurlencode($makeLocalRecord).'" onclick="'.htmlspecialchars('return confirm('.$LANG->JScharCode($LANG->getLL('makeLocalMsg')).');').'">'.$str.'</a>';
	}

	";i:1;i:0;}s:12:"content_size";i:245;s:13:"content_lines";i:5;s:6:"atLine";i:873;}i:41;a:7:{s:6:"header";s:47:"function linkPaste($str,$params,$target,$cmd)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:103:"

Returns an HTML link for pasting a content element. Pasting means either copying or moving a record.
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:15:"$str: The label";}i:1;a:2:{i:0;s:6:"string";i:1;s:96:"$params: The parameters defining the original record. Example: pages:78:sDEF:field_contentarea:0";}i:2;a:2:{i:0;s:6:"string";i:1;s:78:"$target: The parameters defining the target where to paste the original record";}i:3;a:2:{i:0;s:6:"string";i:1;s:67:"$cmd: The paste mode, usually set in the clipboard: 'cut' or 'copy'";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:55:"HTML anchor tag containing the label and the paste-link";}}s:7:"content";a:2:{i:0;s:198:"		return '<a href="index.php?'.$this->linkParams().'&SET[clip]=&SET[clip_parentPos]=&pasteRecord='.$cmd.'&destination='.rawurlencode($params).'&target='.rawurlencode($target).'">'.$str.'</a>';
	}

	";i:1;i:0;}s:12:"content_size";i:198;s:13:"content_lines";i:3;s:6:"atLine";i:888;}i:43;a:7:{s:6:"header";s:44:"function linkCopyCut($str,$parentPos,$cmd)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:114:"

Returns an HTML link for marking a content element (i.e. transferring to the clipboard) for copying or cutting.
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:15:"$str: The label";}i:1;a:2:{i:0;s:6:"string";i:1;s:113:"$parentPos: The parameters defining the original record. Example: pages:78:sDEF:field_contentarea::tt_content:115";}i:2;a:2:{i:0;s:6:"string";i:1;s:39:"$cmd: The marking mode: 'cut' or 'copy'";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:58:"HTML anchor tag containing the label and the cut/copy link";}}s:7:"content";a:2:{i:0;s:158:"		return '<a href="index.php?'.$this->linkParams().'&SET[clip]='.($parentPos?$cmd:'').'&SET[clip_parentPos]='.rawurlencode($parentPos).'">'.$str.'</a>';
	}

	";i:1;i:0;}s:12:"content_size";i:158;s:13:"content_lines";i:3;s:6:"atLine";i:900;}i:45;a:7:{s:6:"header";s:46:"function renderPreviewContent ($row, $table) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:223:"

Returns an HTMLized preview of a certain content element. If you'd like to register a new content type, you can easily extend
this function before the switch clause. Set $alreadyHandled if you provided a preview content.
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:108:"$row: The row containing the content element record; especially $row['CType'] and $row['bodytext'] are used.";}i:1;a:2:{i:0;s:6:"string";i:1;s:39:"$table: Name of the CType's MySQL table";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:20:"HTML preview content";}}s:7:"content";a:2:{i:0;s:507:"
			// Preview content for non-flexible content elements:
		switch($row['CType'])	{
			case 'text':		//	Text
			case 'table':		//	Table
			case 'mailform':	//	Form
				$out='<strong>'.$GLOBALS['LANG']->sL(t3lib_BEfunc::getItemLabel('tt_content','bodytext'),1).'</strong> '.$this->linkEdit(htmlspecialchars(t3lib_div::fixed_lgd(trim(strip_tags($row['bodytext'])),200)),$table,
[...]
pe name for unhandled CType
					$out='<strong>'.htmlspecialchars ($row['CType']).'</strong>';
				}
		}
		return $out;
	}

	";i:1;i:1;}s:12:"content_size";i:3701;s:13:"content_lines";i:58;s:6:"atLine";i:912;}i:47;a:7:{s:6:"header";s:46:"function checkRulesForElement ($table, $uid) {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:56:"

Checks if an element's children comply with the rules
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:27:"The content element's table";}i:1;a:2:{i:0;s:7:"integer";i:1;s:17:"The element's uid";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:72:"		return $this->rulesObj->evaluateRulesForElement ($table, $uid);
	 }

	";i:1;i:0;}s:12:"content_size";i:72;s:13:"content_lines";i:3;s:6:"atLine";i:978;}i:49;a:7:{s:6:"header";s:28:"function printContent()    {";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:29:"

Prints out the module HTML
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:28:"		echo $this->content;
	}

	";i:1;i:0;}s:12:"content_size";i:28;s:13:"content_lines";i:3;s:6:"atLine";i:987;}i:51;a:7:{s:6:"header";s:23:"function linkParams()	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:25:"

[Describe function...]
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:271:"		$output = 'id='.$this->id.
				(is_array($this->altRoot) ? t3lib_div::implodeArrayForUrl('altRoot',$this->altRoot) : '');
		return $output;
	}






	/********************************************
	 *
	 * Processing
	 *
	 ********************************************/

	";i:1;i:0;}s:12:"content_size";i:271;s:13:"content_lines";i:16;s:6:"atLine";i:996;}i:53;a:8:{s:6:"header";s:46:"function createPage($pageArray,$positionPid)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:11:"sectionText";a:1:{i:0;s:10:"Processing";}s:4:"cDat";a:3:{s:4:"text";s:54:"

Performs the neccessary steps to creates a new page
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:56:"$pageArray: array containing the fields for the new page";}i:1;a:2:{i:0;s:7:"integer";i:1;s:55:"$positionPid: location within the page tree (parent id)";}}s:6:"return";a:2:{i:0;s:7:"integer";i:1;s:26:"uid of the new page record";}}s:7:"content";a:2:{i:0;s:507:"		$dataArr = array();
		$dataArr['pages']['NEW'] = $pageArray;
		$dataArr['pages']['NEW']['pid'] = $positionPid;
		if (is_null($dataArr['pages']['NEW']['hidden'])) {
			$dataArr['pages']['NEW']['hidden'] = 0;
		}
		unset($dataArr['pages']['NEW']['uid']);

			// If no data structure is set, try to find one by using the template object
		if ($dataArr['pages']['NEW']['tx_temp
[...]
ripslashes_values=0;
		$tce->start($dataArr,array());
		$tce->process_datamap();
		return $tce->substNEWwithIDs['NEW'];
	}

	";i:1;i:1;}s:12:"content_size";i:857;s:13:"content_lines";i:21;s:6:"atLine";i:1020;}i:55;a:7:{s:6:"header";s:68:"function createDefaultRecords ($table, $uid, $prevDS=-1, $level=0)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:5:{s:4:"text";s:373:"

Creates default records which are defined in the datastructure's rules scheme. The property in the DS is called "ruleDefaultElements"
and consists of elements only (instead of a real regular expression)! I.e. if your regular expression is like this: "(ab){2}c", it makes
sense having ruleDefaultElements contain this list of elements: "ababc".

Calls itself recursively.
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:50:"$table: The table, usually "pages" or "tt_content"";}i:1;a:2:{i:0;s:7:"integer";i:1;s:13:"$uid: The UID";}i:2;a:2:{i:0;s:7:"integer";i:1;s:109:"$prevDS: Internally used to make sure data structures are not created recursively ("previous data structure")";}i:3;a:2:{i:0;s:7:"integer";i:1;s:64:"$level: Internally used for determine the level of recursiveness";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:7:"nothing";}s:5:"other";a:1:{i:0;s:106:"@todo				Check for rules compliance? (might not be necessary if we expect ruleDefaultElements to be valid)";}s:11:"other_index";a:1:{s:5:"@todo";a:1:{i:0;s:97:"Check for rules compliance? (might not be necessary if we expect ruleDefaultElements to be valid)";}}}s:7:"content";a:2:{i:0;s:507:"		global $TCA, $LANG;

		$tableRow = t3lib_BEfunc::getRecord ($table, $uid);
			// Recursivity check and only care about page records or flexible content elements:
		if (($level<10) &&
		    ($tableRow['tx_templavoila_ds'] != $prevDS) &&
		    ($table != 'tt_content' || $tableRow['CType'] == 'templavoila_pi1')
		   ) {
			$recRow = t3lib_BEfunc::getRecord ('tx_templavoila_
[...]

								$this->insertRecord($table.':'.intval($uid).':sDEF:'.$key,$conf);
								break;
						}
					}
				}
			}
		}
	}

	";i:1;i:1;}s:12:"content_size";i:1787;s:13:"content_lines";i:42;s:6:"atLine";i:1056;}i:57;a:7:{s:6:"header";s:40:"function insertRecord($createNew,$row)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:46:"

Inserts a new record (page content element)
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:56:"$createNew: consists of several parts separated by colon";}i:1;a:2:{i:0;s:5:"array";i:1;s:54:"$row: Array of parameters for creating the new record.";}}s:6:"return";a:2:{i:0;s:7:"integer";i:1;s:43:"uid of the created content element (if any)";}}s:7:"content";a:2:{i:0;s:157:"		$handler = t3lib_div::makeInstance('tx_templavoila_xmlrelhndl');
		$handler->init($this->altRoot);

		return $handler->insertRecord($createNew,$row);
	}

	";i:1;i:0;}s:12:"content_size";i:157;s:13:"content_lines";i:6;s:6:"atLine";i:1106;}i:59;a:7:{s:6:"header";s:56:"function pasteRecord($pasteCmd, $target, $destination)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:52:"

Performs the processing part of pasting a record.
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:53:"$pasteCmd: Kind of pasting: 'cut', 'copy' or 'unlink'";}i:1;a:2:{i:0;s:6:"string";i:1;s:88:"$target: String defining the original record. Example: pages:78:sDEF:field_contentarea:0";}i:2;a:2:{i:0;s:6:"string";i:1;s:100:"$destination: Defines the destination where to paste the record (not used when unlinking of course).";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:7:"nothing";}}s:7:"content";a:2:{i:0;s:305:"		$handler = t3lib_div::makeInstance('tx_templavoila_xmlrelhndl');
		$handler->init($this->altRoot);

		return $handler->pasteRecord($pasteCmd, $target, $destination);
	}





	/********************************************
	 *
	 * Structure functions
	 *
	 ********************************************/

	";i:1;i:0;}s:12:"content_size";i:305;s:13:"content_lines";i:16;s:6:"atLine";i:1121;}i:61;a:8:{s:6:"header";s:44:"function getStorageFolderPid($positionPid)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:11:"sectionText";a:1:{i:0;s:19:"Structure functions";}s:4:"cDat";a:3:{s:4:"text";s:139:"

Gets the page ID of the folder containing the template objects (for our template selector).
The storage folder is used for that purpose.
";s:5:"param";a:1:{i:0;a:2:{i:0;s:7:"integer";i:1;s:12:"$positionPid";}}s:6:"return";a:2:{i:0;s:7:"integer";i:1;s:25:"PID of the storage folder";}}s:7:"content";a:2:{i:0;s:384:"			// Negative PID values is pointing to a page on the same level as the current.
		if ($positionPid<0) {
			$pidRow = t3lib_BEfunc::getRecord('pages',abs($positionPid),'pid');
			$positionPid = $pidRow['pid'];
		}
		$row = t3lib_BEfunc::getRecord('pages',$positionPid);

		$TSconfig = t3lib_BEfunc::getTCEFORM_TSconfig('pages',$row);
		return intval($TSconfig['_STORAGE_PID']);
	}

	";i:1;i:0;}s:12:"content_size";i:384;s:13:"content_lines";i:11;s:6:"atLine";i:1145;}i:63;a:4:{s:6:"header";s:66:"function getDStreeForPage($table, $id, $prevRecList='', $row='')	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:49:"

Returns the data structure for a certain page.
";s:5:"param";a:4:{i:0;a:2:{i:0;s:6:"string";i:1;s:128:"$table: Table which contains the element. Only records from table 'pages' or free content elements from 'tt_content' are handled";}i:1;a:2:{i:0;s:7:"integer";i:1;s:26:"$id: The uid of the record";}i:2;a:2:{i:0;s:6:"string";i:1;s:79:"$prevRecList: comma separated list of uids, used internally for recursive calls";}i:3;a:2:{i:0;s:5:"array";i:1;s:58:"$row: Row of a record, used internally for recursive calls";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:23:"The data structure tree";}}s:6:"atLine";i:1166;}i:65;a:7:{s:6:"header";s:57:"function getExpandedDataStructure($table, $field, $row)	{";s:11:"parentClass";s:22:"tx_templavoila_module1";s:4:"cDat";a:3:{s:4:"text";s:83:"

Returns the data structure for a flexform field ($field) from $table (from $row)
";s:5:"param";a:3:{i:0;a:2:{i:0;s:6:"string";i:1;s:14:"The table name";}i:1;a:2:{i:0;s:6:"string";i:1;s:14:"The field name";}i:2;a:2:{i:0;s:5:"array";i:1;s:74:"The data row (used to get DS if DS is dependant on the data in the record)";}}s:6:"return";a:2:{i:0;s:5:"array";i:1;s:51:"The data structure, expanded for all sheets inside.";}}s:7:"content";a:2:{i:0;s:507:"		global $TCA;

		t3lib_div::loadTCA ($table);
		$conf = $TCA[$table]['columns'][$field]['config'];
		$dataStructArray = t3lib_BEfunc::getFlexFormDS($conf, $row, $table);

		$output=array();
		if (is_array($dataStructArray['sheets']))	{
			foreach($dataStructArray['sheets'] as $sheetKey => $sheetInfo)	{
				list ($dataStruct, $sheet) = t3lib_div::resolveSheetDefInDS($dataS
[...]
 instance:
$SOBE = t3lib_div::makeInstance('tx_templavoila_module1');
$SOBE->init();
$SOBE->main();
$SOBE->printContent();
?>";i:1;i:1;}s:12:"content_size";i:1038;s:13:"content_lines";i:34;s:6:"atLine";i:1248;}}}s:14:"MD5_a9c8193694";a:4:{s:8:"filename";s:32:"pi1/class.tx_templavoila_pi1.php";s:8:"filesize";i:15781;s:6:"header";a:5:{s:4:"text";s:61:"

Plugin 'Flexible Content' for the 'templavoila' extension.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:45:"@author    Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:7:{i:1;a:8:{s:6:"header";s:47:"class tx_templavoila_pi1 extends tslib_pibase {";s:5:"class";i:1;s:11:"parentClass";s:18:"tx_templavoila_pi1";s:4:"cDat";a:5:{s:4:"text";s:61:"

Plugin 'Flexible Content' for the 'templavoila' extension.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:45:"@author    Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:7:"content";a:2:{i:0;s:429:"    var $prefixId = 'tx_templavoila_pi1';        // Same as class name
    var $scriptRelPath = 'pi1/class.tx_templavoila_pi1.php';    // Path to this script relative to the extension dir.
    var $extKey = 'templavoila';    // The extension key.

	var $inheritValueFromDefault=1;		// If set, children-translations will take the value from the default if "false" (zero or blank)

	var $conf=array();					// TypoScript config.


	";i:1;i:-1;}s:12:"content_size";i:429;s:13:"content_lines";i:9;s:6:"atLine";i:65;}i:3;a:7:{s:6:"header";s:34:"function main($content,$conf)    {";s:11:"parentClass";s:18:"tx_templavoila_pi1";s:4:"cDat";a:3:{s:4:"text";s:74:"

Main function for rendering of Flexible Content elements of TemplaVoila
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:31:"Standard content input. Ignore.";}i:1;a:2:{i:0;s:5:"array";i:1;s:32:"TypoScript array for the plugin.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:47:"HTML content for the Flexible Content elements.";}}s:7:"content";a:2:{i:0;s:98:"		$this->initVars($conf);
		return $this->renderElement($this->cObj->data, 'tt_content');
    }

	";i:1;i:0;}s:12:"content_size";i:98;s:13:"content_lines";i:4;s:6:"atLine";i:82;}i:5;a:7:{s:6:"header";s:39:"function main_page($content,$conf)    {";s:11:"parentClass";s:18:"tx_templavoila_pi1";s:4:"cDat";a:3:{s:4:"text";s:63:"

Main function for rendering of Page Templates of TemplaVoila
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"string";i:1;s:31:"Standard content input. Ignore.";}i:1;a:2:{i:0;s:5:"array";i:1;s:32:"TypoScript array for the plugin.";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:44:"HTML content for the Page Template elements.";}}s:7:"content";a:2:{i:0;s:507:"		$this->initVars($conf);

			// Current page record which we MIGHT manipulate a little:
		$pageRecord = $GLOBALS['TSFE']->page;

			// Find DS and Template in root line IF there is no Data Structure set for the current page:
		if (!$pageRecord['tx_templavoila_ds'])	{
			foreach($GLOBALS['TSFE']->tmpl->rootLine as $pRec)	{
				if ($pageRecord['uid'] != $pRec['uid'])	{
				
[...]
 $pRec['tx_templavoila_to'];
					}
				} else break;
			}
		}

		return $this->renderElement($pageRecord, 'pages');
    }

	";i:1;i:1;}s:12:"content_size";i:906;s:13:"content_lines";i:23;s:6:"atLine";i:94;}i:7;a:7:{s:6:"header";s:26:"function initVars($conf)	{";s:11:"parentClass";s:18:"tx_templavoila_pi1";s:4:"cDat";a:3:{s:4:"text";s:67:"

Will set up various stuff in the class based on input TypoScript
";s:5:"param";a:1:{i:0;a:2:{i:0;s:5:"array";i:1;s:18:"TypoScript options";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:7:"content";a:2:{i:0;s:107:"		$this->inheritValueFromDefault = $conf['dontInheritValueFromDefault'] ? 0 : 1;
		$this->conf=$conf;
	}

	";i:1;i:0;}s:12:"content_size";i:107;s:13:"content_lines";i:4;s:6:"atLine";i:124;}i:9;a:7:{s:6:"header";s:37:"function renderElement($row,$table)	{";s:11:"parentClass";s:18:"tx_templavoila_pi1";s:4:"cDat";a:3:{s:4:"text";s:242:"

Common function for rendering of the Flexible Content / Page Templates.
For Page Templates the input row may be manipulated to contain the proper reference to a data structure (pages can have those inherited which content elements cannot).
";s:5:"param";a:2:{i:0;a:2:{i:0;s:5:"array";i:1;s:64:"Current data record, either a tt_content element or page record.";}i:1;a:2:{i:0;s:6:"string";i:1;s:43:"Table name, either "pages" or "tt_content".";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:12:"HTML output.";}}s:7:"content";a:2:{i:0;s:507:"		if ($GLOBALS['TT']->LR) $GLOBALS['TT']->push('Get DS, TO and data');

			// Get data structure:
		$srcPointer = $row['tx_templavoila_ds'];
		if (t3lib_div::testInt($srcPointer))	{	// If integer, then its a record we will look up:
			$DSrec = $GLOBALS['TSFE']->sys_page->checkRecord('tx_templavoila_datastructure',$srcPointer);
			$DS = t3lib_div::xml2array($DSrec['dataprot
[...]
$content = $this->pi_getEditIcon($content,'tx_templavoila_flex','Edit element',$row,$table,$eIconf);
		return $content;
	}

	";i:1;i:1;}s:12:"content_size";i:3474;s:13:"content_lines";i:71;s:6:"atLine";i:137;}i:11;a:4:{s:6:"header";s:83:"function processDataValues(&$dataValues,$DSelements,$TOelements,$valueKey='vDEF')	{";s:11:"parentClass";s:18:"tx_templavoila_pi1";s:4:"cDat";a:3:{s:4:"text";s:326:"

Performing pre-processing of the data array.
This will transform the data in the data array according to various rules before the data is merged with the template HTML
Notice that $dataValues is changed internally as a reference so the function returns no content but internally changes the passed variable for $dataValues.
";s:5:"param";a:4:{i:0;a:2:{i:0;s:5:"array";i:1;s:76:"The data values from the XML file (converted to array). Passed by reference.";}i:1;a:2:{i:0;s:5:"array";i:1;s:78:"The data structure definition which the data in the dataValues array reflects.";}i:2;a:2:{i:0;s:5:"array";i:1;s:78:"The local XML processing information found in associated Template Objects (TO)";}i:3;a:2:{i:0;s:6:"string";i:1;s:9:"Value key";}}s:6:"return";a:2:{i:0;s:4:"void";i:1;s:0:"";}}s:6:"atLine";i:220;}i:13;a:7:{s:6:"header";s:31:"function formatError($string)	{";s:11:"parentClass";s:18:"tx_templavoila_pi1";s:4:"cDat";a:5:{s:4:"text";s:47:"

Creates an error message for frontend output
";s:5:"param";a:1:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:12:"$string: ...";}}s:6:"return";a:2:{i:0;s:6:"string";i:1;s:20:"Error message output";}s:5:"other";a:1:{i:0;s:35:"@string	string		Error message input";}s:11:"other_index";a:1:{s:7:"@string";a:1:{i:0;s:26:"string Error message input";}}}s:7:"content";a:2:{i:0;s:507:"
			// Set no-cache since the error message shouldn't be cached of course...
		$GLOBALS['TSFE']->set_no_cache();

			//
		$output = '
			<!-- TemplaVoila ERROR message: -->
			<div class="tx_templavoila_pi1-error" style="
					border: 2px red solid;
					background-color: yellow;
					color: black;
					text-align: center;
					padding: 20px 20px 20px 20px;
					margin: 20
[...]
p'])    {
    include_once($TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/pi1/class.tx_templavoila_pi1.php']);
}
?>
";i:1;i:1;}s:12:"content_size";i:778;s:13:"content_lines";i:26;s:6:"atLine";i:355;}}}s:14:"MD5_b706754668";a:4:{s:8:"filename";s:32:"pi2/class.tx_templavoila_pi2.php";s:8:"filesize";i:2688;s:6:"header";a:5:{s:4:"text";s:56:"

Plugin 'Data Source' for the 'templavoila' extension.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:45:"@author    Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:3:"DAT";a:2:{i:1;a:5:{s:6:"header";s:47:"class tx_templavoila_pi2 extends tslib_pibase {";s:5:"class";i:1;s:11:"parentClass";s:18:"tx_templavoila_pi2";s:4:"cDat";a:5:{s:4:"text";s:56:"

Plugin 'Data Source' for the 'templavoila' extension.
";s:5:"param";a:0:{}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}s:5:"other";a:3:{i:0;s:45:"@author    Kasper Skaarhoj <kasper@typo3.com>";i:1;s:14:"@package TYPO3";i:2;s:26:"@subpackage tx_templavoila";}s:11:"other_index";a:3:{s:7:"@author";a:1:{i:0;s:34:"Kasper Skaarhoj <kasper@typo3.com>";}s:8:"@package";a:1:{i:0;s:6:"TYPO3 ";}s:11:"@subpackage";a:1:{i:0;s:15:"tx_templavoila ";}}}s:6:"atLine";i:57;}i:3;a:7:{s:6:"header";s:34:"function main($content,$conf)    {";s:11:"parentClass";s:18:"tx_templavoila_pi2";s:4:"cDat";a:3:{s:4:"text";s:30:"

[Put your description here]
";s:5:"param";a:2:{i:0;a:2:{i:0;s:6:"[type]";i:1;s:13:"$content: ...";}i:1;a:2:{i:0;s:6:"[type]";i:1;s:10:"$conf: ...";}}s:6:"return";a:2:{i:0;s:6:"[type]";i:1;s:3:"...";}}s:7:"content";a:2:{i:0;s:469:"        return '
		
		<h3>Include a Data Source?</h3>
		<p>Robert Lemke has some ideas for this. He will probably be in charge of writing this part of the plugin (which is obviously not written yet...).</p>
		
		
		';
    }
}


if (defined('TYPO3_MODE') && $TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/pi2/class.tx_templavoila_pi2.php'])    {
    include_once($TYPO3_CONF_VARS[TYPO3_MODE]['XCLASS']['ext/templavoila/pi2/class.tx_templavoila_pi2.php']);
}
?>
";i:1;i:0;}s:12:"content_size";i:469;s:13:"content_lines";i:15;s:6:"atLine";i:69;}}}}}